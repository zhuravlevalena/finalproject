{"version":3,"file":"collect-point.mjs","sources":["../../../extensions/aligning_guidelines/util/collect-point.ts"],"sourcesContent":["import type { FabricObject, Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\ntype CollectPointProps = {\n  target: FabricObject;\n  /** Operation points of the target element: top-left, bottom-left, top-right, bottom-right */\n  point: Point;\n  /** Position using diagonal points when resizing/scaling. */\n  diagonalPoint: Point;\n  /** Set of points to consider for alignment: [tl, tr, br, bl, center] */\n  list: Point[];\n  /** Change the zoom or change the size, determine by whether e.transform.action starts with the string \"scale\" */\n  isScale: boolean;\n  /** Whether to change uniformly is determined by canvas.uniformScaling and canvas.uniScaleKey. */\n  isUniform: boolean;\n  /** When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center. */\n  isCenter: boolean;\n  /** tl、tr、br、bl、mt、mr、mb、ml */\n  corner: string;\n};\n\nexport function collectVerticalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'x');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].x - point.x;\n  // tl bl ml\n  // If modifying on the left side, the size decreases; conversely, it increases.\n  const dirX = corner.includes('l') ? -1 : 1;\n  v *= dirX;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleWidth = scaleX * width + dStrokeWidth;\n  const sx = (v + scaleWidth) / scaleWidth;\n  // When v equals -scaleWidth, sx equals 0.\n  if (sx == 0) return [];\n  if (isScale) {\n    target.set('scaleX', scaleX * sx);\n    if (isUniform) target.set('scaleY', scaleY * sx);\n  } else {\n    target.set('width', width * sx);\n    if (isUniform) target.set('height', height * sx);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n\nexport function collectHorizontalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'y');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].y - point.y;\n  // tl mt tr\n  // If modifying on the top side, the size decreases; conversely, it increases.\n  const dirY = corner.includes('t') ? -1 : 1;\n  v *= dirY;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleHeight = scaleY * height + dStrokeWidth;\n  const sy = (v + scaleHeight) / scaleHeight;\n  // When v equals -scaleHeight, sy equals 0.\n  if (sy == 0) return [];\n  if (isScale) {\n    target.set('scaleY', scaleY * sy);\n    if (isUniform) target.set('scaleX', scaleX * sy);\n  } else {\n    target.set('height', height * sy);\n    if (isUniform) target.set('width', width * sy);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n"],"names":["collectVerticalPoint","props","target","isScale","isUniform","corner","point","diagonalPoint","list","isCenter","dis","arr","getDistanceList","margin","canvas","getZoom","v","length","x","dirX","includes","width","height","scaleX","scaleY","dStrokeWidth","strokeUniform","strokeWidth","scaleWidth","sx","set","setRelativeXY","originArr","contraryOriginMap","setCoords","map","origin","collectHorizontalPoint","y","dirY","scaleHeight","sy"],"mappings":"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"}