{"version":3,"file":"Composed.min.mjs","sources":["../../../src/filters/Composed.ts"],"sourcesContent":["import { BaseFilter } from './BaseFilter';\nimport type { T2DPipelineState, TWebGLPipelineState } from './typedefs';\nimport { isWebGLPipelineState } from './utils';\nimport { classRegistry } from '../ClassRegistry';\n\ntype ComposedOwnProps = {\n  subFilters: BaseFilter<string, object, object>[];\n};\n\ntype ComposedSerializedProps = {\n  subFilters: Record<string, unknown>[];\n};\n\n/**\n * A container class that knows how to apply a sequence of filters to an input image.\n */\nexport class Composed extends BaseFilter<\n  'Composed',\n  ComposedOwnProps,\n  ComposedSerializedProps\n> {\n  /**\n   * A non sparse array of filters to apply\n   */\n  declare subFilters: ComposedOwnProps['subFilters'];\n\n  static type = 'Composed';\n\n  constructor(\n    options: { subFilters?: BaseFilter<string>[] } & Record<string, any> = {},\n  ) {\n    super(options);\n    this.subFilters = options.subFilters || [];\n  }\n\n  /**\n   * Apply this container's filters to the input image provided.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be applied.\n   */\n  applyTo(options: TWebGLPipelineState | T2DPipelineState) {\n    if (isWebGLPipelineState(options)) {\n      options.passes += this.subFilters.length - 1;\n    }\n    this.subFilters.forEach((filter) => {\n      filter.applyTo(options);\n    });\n  }\n\n  /**\n   * Serialize this filter into JSON.\n   * @returns {Object} A JSON representation of this filter.\n   */\n  toObject() {\n    return {\n      type: this.type,\n      subFilters: this.subFilters.map((filter) => filter.toObject()),\n    };\n  }\n\n  isNeutralState() {\n    return !this.subFilters.some((filter) => !filter.isNeutralState());\n  }\n\n  /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   * @param {oject} object Object to create an instance from\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] handle aborting `BlendImage` filter loading, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n   * @returns {Promise<Composed>}\n   */\n  static fromObject(\n    object: Record<string, any>,\n    options?: { signal: AbortSignal },\n  ): Promise<Composed> {\n    return Promise.all(\n      ((object.subFilters || []) as BaseFilter<string>[]).map((filter) =>\n        classRegistry\n          .getClass<typeof BaseFilter>(filter.type)\n          .fromObject(filter, options),\n      ),\n    ).then((enlivedFilters) => new this({ subFilters: enlivedFilters }));\n  }\n}\n\nclassRegistry.setClass(Composed);\n"],"names":["Composed","BaseFilter","constructor","options","arguments","length","undefined","super","this","subFilters","applyTo","isWebGLPipelineState","passes","forEach","filter","toObject","type","map","isNeutralState","some","fromObject","object","Promise","all","classRegistry","getClass","then","enlivedFilters","_defineProperty","setClass"],"mappings":"oPAgBO,MAAMA,UAAiBC,EAY5BC,WAAAA,GAEE,IADAC,EAAoEC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAA,EAEvEG,MAAMJ,GACNK,KAAKC,WAAaN,EAAQM,YAAc,EAC1C,CAQAC,OAAAA,CAAQP,GACFQ,EAAqBR,KACvBA,EAAQS,QAAUJ,KAAKC,WAAWJ,OAAS,GAE7CG,KAAKC,WAAWI,QAASC,IACvBA,EAAOJ,QAAQP,IAEnB,CAMAY,QAAAA,GACE,MAAO,CACLC,KAAMR,KAAKQ,KACXP,WAAYD,KAAKC,WAAWQ,IAAKH,GAAWA,EAAOC,YAEvD,CAEAG,cAAAA,GACE,OAAQV,KAAKC,WAAWU,KAAML,IAAYA,EAAOI,iBACnD,CASA,iBAAOE,CACLC,EACAlB,GAEA,OAAOmB,QAAQC,KACXF,EAAOZ,YAAc,IAA6BQ,IAAKH,GACvDU,EACGC,SAA4BX,EAAOE,MACnCI,WAAWN,EAAQX,KAExBuB,KAAMC,GAAmB,IAAInB,KAAK,CAAEC,WAAYkB,IACpD,EA9DAC,EALW5B,EAAQ,OAUL,YA4DhBwB,EAAcK,SAAS7B"}