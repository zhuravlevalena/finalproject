{"version":3,"file":"Canvas2dFilterBackend.min.mjs","sources":["../../../src/filters/Canvas2dFilterBackend.ts"],"sourcesContent":["/**\n * Canvas 2D filter backend.\n */\nimport type { BaseFilter } from './BaseFilter';\nimport type { T2DPipelineState, TPipelineResources } from './typedefs';\n\nexport class Canvas2dFilterBackend {\n  /**\n   * Experimental. This object is a sort of repository of help layers used to avoid\n   * of recreating them during frequent filtering. If you are previewing a filter with\n   * a slider you probably do not want to create help layers every filter step.\n   * in this object there will be appended some canvases, created once, resized sometimes\n   * cleared never. Clearing is left to the developer.\n   **/\n  resources: TPipelineResources = {};\n\n  /**\n   * Apply a set of filters against a source image and draw the filtered output\n   * to the provided destination canvas.\n   *\n   * @param {EnhancedFilter} filters The filter to apply.\n   * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.\n   * @param {Number} sourceWidth The width of the source input.\n   * @param {Number} sourceHeight The height of the source input.\n   * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n   */\n  applyFilters(\n    filters: BaseFilter<string, Record<string, any>>[],\n    sourceElement: CanvasImageSource,\n    sourceWidth: number,\n    sourceHeight: number,\n    targetCanvas: HTMLCanvasElement,\n  ): T2DPipelineState | void {\n    const ctx = targetCanvas.getContext('2d', {\n      willReadFrequently: true,\n      desynchronized: true,\n    });\n    if (!ctx) {\n      return;\n    }\n    ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);\n    const imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n    const originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n    const pipelineState: T2DPipelineState = {\n      sourceWidth,\n      sourceHeight,\n      imageData,\n      originalEl: sourceElement,\n      originalImageData,\n      canvasEl: targetCanvas,\n      ctx,\n      filterBackend: this,\n    };\n    filters.forEach((filter) => {\n      filter.applyTo(pipelineState);\n    });\n    const { imageData: imageDataPostFilter } = pipelineState;\n    if (\n      imageDataPostFilter.width !== sourceWidth ||\n      imageDataPostFilter.height !== sourceHeight\n    ) {\n      targetCanvas.width = imageDataPostFilter.width;\n      targetCanvas.height = imageDataPostFilter.height;\n    }\n    ctx.putImageData(imageDataPostFilter, 0, 0);\n    return pipelineState;\n  }\n}\n"],"names":["Canvas2dFilterBackend","constructor","_defineProperty","this","applyFilters","filters","sourceElement","sourceWidth","sourceHeight","targetCanvas","ctx","getContext","willReadFrequently","desynchronized","drawImage","pipelineState","imageData","getImageData","originalEl","originalImageData","canvasEl","filterBackend","forEach","filter","applyTo","imageDataPostFilter","width","height","putImageData"],"mappings":"kFAMO,MAAMA,EAAsBC,WAAAA,GACjCC,EAAAC,KAAA,YAOgC,GAAE,CAYlCC,YAAAA,CACEC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAMD,EAAaE,WAAW,KAAM,CACxCC,oBAAoB,EACpBC,gBAAgB,IAElB,IAAKH,EACH,OAEFA,EAAII,UAAUR,EAAe,EAAG,EAAGC,EAAaC,GAChD,MAEMO,EAAkC,CACtCR,cACAC,eACAQ,UALgBN,EAAIO,aAAa,EAAG,EAAGV,EAAaC,GAMpDU,WAAYZ,EACZa,kBANwBT,EAAIO,aAAa,EAAG,EAAGV,EAAaC,GAO5DY,SAAUX,EACVC,MACAW,cAAelB,MAEjBE,EAAQiB,QAASC,IACfA,EAAOC,QAAQT,KAEjB,MAAQC,UAAWS,GAAwBV,EAS3C,OAPEU,EAAoBC,QAAUnB,GAC9BkB,EAAoBE,SAAWnB,IAE/BC,EAAaiB,MAAQD,EAAoBC,MACzCjB,EAAakB,OAASF,EAAoBE,QAE5CjB,EAAIkB,aAAaH,EAAqB,EAAG,GAClCV,CACT"}