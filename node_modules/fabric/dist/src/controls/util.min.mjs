import{resolveOrigin as n}from"../util/misc/resolveOrigin.min.mjs";import{Point as t}from"../Point.min.mjs";import{degreesToRadians as o}from"../util/misc/radiansDegreesConversion.min.mjs";import{twoMathPi as r,quarterPI as i,CENTER as e}from"../constants.min.mjs";import{calcVectorRotation as s,createVector as m}from"../util/misc/vectors.min.mjs";import{sendPointToPlane as a}from"../util/misc/planeChange.min.mjs";const c="not-allowed",f=(n,t,o,r)=>{if(!t||!n)return"drag";const i=r.controls[t];return i.getActionName(o,i,r)};function u(t){return n(t.originX)===n(e)&&n(t.originY)===n(e)}function l(t){return.5-n(t)}const g=(n,t)=>n[t],v=(n,o,r,i)=>({e:n,transform:o,pointer:new t(r,i)});function p(n,t,o){const e=o,c=a(n.getCenterPoint(),n.canvas.viewportTransform,void 0),f=s(m(c,e))+r;return Math.round(f%r/i)}function d(n,r,i,s,m){var a;let{target:c,corner:f}=n;const u=c.controls[f],l=(null===(a=c.canvas)||void 0===a?void 0:a.getZoom())||1,g=c.padding/l,v=function(n,r,i,s){const m=n.getRelativeCenterPoint(),a=void 0!==i&&void 0!==s?n.translateToGivenOrigin(m,e,e,i,s):new t(n.left,n.top);return(n.angle?r.rotate(-o(n.angle),m):r).subtract(a)}(c,new t(s,m),r,i);return v.x>=g&&(v.x-=g),v.x<=-g&&(v.x+=g),v.y>=g&&(v.y-=g),v.y<=g&&(v.y+=g),v.x-=u.offsetX,v.y-=u.offsetY,v}export{c as NOT_ALLOWED_CURSOR,v as commonEventInfo,p as findCornerQuadrant,f as getActionFromCorner,d as getLocalPoint,l as invertOrigin,g as isLocked,u as isTransformCentered};
//# sourceMappingURL=util.min.mjs.map
