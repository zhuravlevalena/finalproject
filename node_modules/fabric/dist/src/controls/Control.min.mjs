import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Intersection as r}from"../Intersection.min.mjs";import{Point as e}from"../Point.min.mjs";import{SCALE as i,STROKE as o,FILL as s}from"../constants.min.mjs";import{multiplyTransformMatrixArray as n,createTranslateMatrix as l,createRotateMatrix as a,createScaleMatrix as c}from"../util/misc/matrix.min.mjs";import{degreesToRadians as m}from"../util/misc/radiansDegreesConversion.min.mjs";import{renderSquareControl as h,renderCircleControl as u}from"./controlRendering.min.mjs";class f{constructor(r){t(this,"visible",!0),t(this,"actionName",i),t(this,"angle",0),t(this,"x",0),t(this,"y",0),t(this,"offsetX",0),t(this,"offsetY",0),t(this,"sizeX",0),t(this,"sizeY",0),t(this,"touchSizeX",0),t(this,"touchSizeY",0),t(this,"cursorStyle","crosshair"),t(this,"withConnection",!1),Object.assign(this,r)}shouldActivate(t,e,i,o){var s;let{tl:n,tr:l,br:a,bl:c}=o;return(null===(s=e.canvas)||void 0===s?void 0:s.getActiveObject())===e&&e.isControlVisible(t)&&r.isPointInPolygon(i,[n,l,a,c])}getActionHandler(t,r,e){return this.actionHandler}getMouseDownHandler(t,r,e){return this.mouseDownHandler}getMouseUpHandler(t,r,e){return this.mouseUpHandler}cursorStyleHandler(t,r,e,i){return r.cursorStyle}getActionName(t,r,e){return r.actionName}getVisibility(t,r){var e,i;return null!==(e=null===(i=t._controlsVisibility)||void 0===i?void 0:i[r])&&void 0!==e?e:this.visible}setVisibility(t,r,e){this.visible=t}positionHandler(t,r,i,o){return new e(this.x*t.x+this.offsetX,this.y*t.y+this.offsetY).transform(r)}calcCornerCoords(t,r,i,o,s,m){const h=n([l(i,o),a({angle:t}),c((s?this.touchSizeX:this.sizeX)||r,(s?this.touchSizeY:this.sizeY)||r)]);return{tl:new e(-.5,-.5).transform(h),tr:new e(.5,-.5).transform(h),br:new e(.5,.5).transform(h),bl:new e(-.5,.5).transform(h)}}commonRenderProps(t,r,e,i){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const{cornerSize:l,cornerColor:a,transparentCorners:c,cornerStrokeColor:h}=n,u=l||i.cornerSize,f=this.sizeX||u,d=this.sizeY||u,p=void 0!==c?c:i.transparentCorners,v=p?o:s,S=h||i.cornerStrokeColor,g=!p&&!!S;return t.fillStyle=a||i.cornerColor||"",t.strokeStyle=S||"",t.translate(r,e),t.rotate(m(i.getTotalAngle())),{stroke:g,xSize:f,ySize:d,transparentCorners:p,opName:v}}render(t,r,e,i,o){if("circle"===((i=i||{}).cornerStyle||o.cornerStyle))u.call(this,t,r,e,i,o);else h.call(this,t,r,e,i,o)}}export{f as Control};
//# sourceMappingURL=Control.min.mjs.map
