{"version":3,"file":"util.min.mjs","sources":["../../../src/controls/util.ts"],"sourcesContent":["import type {\n  TPointerEvent,\n  Transform,\n  TransformAction,\n  BasicTransformEvent,\n} from '../EventTypeDefs';\nimport { resolveOrigin } from '../util/misc/resolveOrigin';\nimport { Point } from '../Point';\nimport type { FabricObject } from '../shapes/Object/FabricObject';\nimport type { TOriginX, TOriginY } from '../typedefs';\nimport { degreesToRadians } from '../util/misc/radiansDegreesConversion';\nimport type { Control } from './Control';\nimport { CENTER, quarterPI, twoMathPi } from '../constants';\nimport { calcVectorRotation, createVector } from '../util/misc/vectors';\nimport type { TOCoord } from '../shapes/Object/InteractiveObject';\nimport { sendPointToPlane } from '../util/misc/planeChange';\n\nexport const NOT_ALLOWED_CURSOR = 'not-allowed';\n\n/**\n * @param {Boolean} alreadySelected true if target is already selected\n * @param {String} corner a string representing the corner ml, mr, tl ...\n * @param {Event} e Event object\n * @param {FabricObject} [target] inserted back to help overriding. Unused\n */\nexport const getActionFromCorner = (\n  alreadySelected: boolean,\n  corner: string | undefined,\n  e: TPointerEvent,\n  target: FabricObject,\n) => {\n  if (!corner || !alreadySelected) {\n    return 'drag';\n  }\n  const control = target.controls[corner];\n  return control.getActionName(e, control, target);\n};\n\n/**\n * Checks if transform is centered\n * @param {Object} transform transform data\n * @return {Boolean} true if transform is centered\n */\nexport function isTransformCentered(transform: Transform) {\n  return (\n    resolveOrigin(transform.originX) === resolveOrigin(CENTER) &&\n    resolveOrigin(transform.originY) === resolveOrigin(CENTER)\n  );\n}\n\nexport function invertOrigin(origin: TOriginX | TOriginY) {\n  return -resolveOrigin(origin) + 0.5;\n}\n\nexport const isLocked = (\n  target: FabricObject,\n  lockingKey:\n    | 'lockMovementX'\n    | 'lockMovementY'\n    | 'lockRotation'\n    | 'lockScalingX'\n    | 'lockScalingY'\n    | 'lockSkewingX'\n    | 'lockSkewingY'\n    | 'lockScalingFlip',\n) => target[lockingKey];\n\nexport const commonEventInfo: TransformAction<\n  Transform,\n  BasicTransformEvent\n> = (eventData, transform, x, y) => {\n  return {\n    e: eventData,\n    transform,\n    pointer: new Point(x, y),\n  };\n};\n\n/**\n * Combine control position and object angle to find the control direction compared\n * to the object center.\n * @param {FabricObject} fabricObject the fabric object for which we are rendering controls\n * @param {Control} control the control class\n * @return {Number} 0 - 7 a quadrant number\n */\nexport function findCornerQuadrant(\n  fabricObject: FabricObject,\n  control: Control,\n  coord: TOCoord,\n): number {\n  const target = coord;\n  const center = sendPointToPlane(\n    fabricObject.getCenterPoint(),\n    fabricObject.canvas!.viewportTransform,\n    undefined,\n  );\n  const angle = calcVectorRotation(createVector(center, target)) + twoMathPi;\n  return Math.round((angle % twoMathPi) / quarterPI);\n}\n\n/**\n * @returns the normalized point (rotated relative to center) in local coordinates\n */\nfunction normalizePoint(\n  target: FabricObject,\n  point: Point,\n  originX: TOriginX,\n  originY: TOriginY,\n): Point {\n  const center = target.getRelativeCenterPoint(),\n    p =\n      typeof originX !== 'undefined' && typeof originY !== 'undefined'\n        ? target.translateToGivenOrigin(\n            center,\n            CENTER,\n            CENTER,\n            originX,\n            originY,\n          )\n        : new Point(target.left, target.top),\n    p2 = target.angle\n      ? point.rotate(-degreesToRadians(target.angle), center)\n      : point;\n  return p2.subtract(p);\n}\n\n/**\n * Transforms a point to the offset from the given origin\n * @param {Object} transform\n * @param {String} originX\n * @param {String} originY\n * @param {number} x\n * @param {number} y\n * @return {Fabric.Point} the normalized point\n */\nexport function getLocalPoint(\n  { target, corner }: Transform,\n  originX: TOriginX,\n  originY: TOriginY,\n  x: number,\n  y: number,\n) {\n  const control = target.controls[corner],\n    zoom = target.canvas?.getZoom() || 1,\n    padding = target.padding / zoom,\n    localPoint = normalizePoint(target, new Point(x, y), originX, originY);\n  if (localPoint.x >= padding) {\n    localPoint.x -= padding;\n  }\n  if (localPoint.x <= -padding) {\n    localPoint.x += padding;\n  }\n  if (localPoint.y >= padding) {\n    localPoint.y -= padding;\n  }\n  if (localPoint.y <= padding) {\n    localPoint.y += padding;\n  }\n  localPoint.x -= control.offsetX;\n  localPoint.y -= control.offsetY;\n  return localPoint;\n}\n"],"names":["NOT_ALLOWED_CURSOR","getActionFromCorner","alreadySelected","corner","e","target","control","controls","getActionName","isTransformCentered","transform","resolveOrigin","originX","CENTER","originY","invertOrigin","origin","isLocked","lockingKey","commonEventInfo","eventData","x","y","pointer","Point","findCornerQuadrant","fabricObject","coord","center","sendPointToPlane","getCenterPoint","canvas","viewportTransform","undefined","angle","calcVectorRotation","createVector","twoMathPi","Math","round","quarterPI","getLocalPoint","_ref","_target$canvas","zoom","getZoom","padding","localPoint","point","getRelativeCenterPoint","p","translateToGivenOrigin","left","top","rotate","degreesToRadians","subtract","normalizePoint","offsetX","offsetY"],"mappings":"iaAiBO,MAAMA,EAAqB,cAQrBC,EAAsBA,CACjCC,EACAC,EACAC,EACAC,KAEA,IAAKF,IAAWD,EACd,MAAO,OAET,MAAMI,EAAUD,EAAOE,SAASJ,GAChC,OAAOG,EAAQE,cAAcJ,EAAGE,EAASD,IAQpC,SAASI,EAAoBC,GAClC,OACEC,EAAcD,EAAUE,WAAaD,EAAcE,IACnDF,EAAcD,EAAUI,WAAaH,EAAcE,EAEvD,CAEO,SAASE,EAAaC,GAC3B,MAAgC,GAAxBL,EAAcK,EACxB,CAEO,MAAMC,EAAWA,CACtBZ,EACAa,IASGb,EAAOa,GAECC,EAGTA,CAACC,EAAWV,EAAWW,EAAGC,KACrB,CACLlB,EAAGgB,EACHV,YACAa,QAAS,IAAIC,EAAMH,EAAGC,KAWnB,SAASG,EACdC,EACApB,EACAqB,GAEA,MAAMtB,EAASsB,EACTC,EAASC,EACbH,EAAaI,iBACbJ,EAAaK,OAAQC,uBACrBC,GAEIC,EAAQC,EAAmBC,EAAaR,EAAQvB,IAAWgC,EACjE,OAAOC,KAAKC,MAAOL,EAAQG,EAAaG,EAC1C,CAqCO,SAASC,EAAaC,EAE3B9B,EACAE,EACAO,EACAC,GACA,IAAAqB,EAAA,IALAtC,OAAEA,EAAMF,OAAEA,GAAmBuC,EAM7B,MAAMpC,EAAUD,EAAOE,SAASJ,GAC9ByC,GAAoB,QAAbD,EAAAtC,EAAO0B,cAAM,IAAAY,OAAA,EAAbA,EAAeE,YAAa,EACnCC,EAAUzC,EAAOyC,QAAUF,EAC3BG,EA1CJ,SACE1C,EACA2C,EACApC,EACAE,GAEA,MAAMc,EAASvB,EAAO4C,yBACpBC,OACqB,IAAZtC,QAA8C,IAAZE,EACrCT,EAAO8C,uBACLvB,EACAf,EACAA,EACAD,EACAE,GAEF,IAAIU,EAAMnB,EAAO+C,KAAM/C,EAAOgD,KAItC,OAHOhD,EAAO6B,MACRc,EAAMM,QAAQC,EAAiBlD,EAAO6B,OAAQN,GAC9CoB,GACIQ,SAASN,EACrB,CAqBiBO,CAAepD,EAAQ,IAAImB,EAAMH,EAAGC,GAAIV,EAASE,GAehE,OAdIiC,EAAW1B,GAAKyB,IAClBC,EAAW1B,GAAKyB,GAEdC,EAAW1B,IAAMyB,IACnBC,EAAW1B,GAAKyB,GAEdC,EAAWzB,GAAKwB,IAClBC,EAAWzB,GAAKwB,GAEdC,EAAWzB,GAAKwB,IAClBC,EAAWzB,GAAKwB,GAElBC,EAAW1B,GAAKf,EAAQoD,QACxBX,EAAWzB,GAAKhB,EAAQqD,QACjBZ,CACT"}