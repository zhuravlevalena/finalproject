{"version":3,"file":"skew.mjs","sources":["../../../src/controls/skew.ts"],"sourcesContent":["import type {\n  ControlCursorCallback,\n  TPointerEvent,\n  Transform,\n  TransformActionHandler,\n} from '../EventTypeDefs';\nimport { resolveOrigin } from '../util/misc/resolveOrigin';\nimport { Point } from '../Point';\nimport type { TAxis, TAxisKey } from '../typedefs';\nimport {\n  degreesToRadians,\n  radiansToDegrees,\n} from '../util/misc/radiansDegreesConversion';\nimport {\n  findCornerQuadrant,\n  getLocalPoint,\n  isLocked,\n  NOT_ALLOWED_CURSOR,\n} from './util';\nimport { wrapWithFireEvent } from './wrapWithFireEvent';\nimport { wrapWithFixedAnchor } from './wrapWithFixedAnchor';\nimport {\n  CENTER,\n  SCALE_X,\n  SCALE_Y,\n  SKEWING,\n  SKEW_X,\n  SKEW_Y,\n} from '../constants';\n\nexport type SkewTransform = Transform & { skewingSide: -1 | 1 };\n\nconst AXIS_KEYS: Record<\n  TAxis,\n  {\n    counterAxis: TAxis;\n    scale: TAxisKey<'scale'>;\n    skew: TAxisKey<'skew'>;\n    lockSkewing: TAxisKey<'lockSkewing'>;\n    origin: TAxisKey<'origin'>;\n    flip: TAxisKey<'flip'>;\n  }\n> = {\n  x: {\n    counterAxis: 'y',\n    scale: SCALE_X,\n    skew: SKEW_X,\n    lockSkewing: 'lockSkewingX',\n    origin: 'originX',\n    flip: 'flipX',\n  },\n  y: {\n    counterAxis: 'x',\n    scale: SCALE_Y,\n    skew: SKEW_Y,\n    lockSkewing: 'lockSkewingY',\n    origin: 'originY',\n    flip: 'flipY',\n  },\n};\n\nconst skewMap = ['ns', 'nesw', 'ew', 'nwse'];\n\n/**\n * return the correct cursor style for the skew action\n * @param {Event} eventData the javascript event that is causing the scale\n * @param {Control} control the control that is interested in the action\n * @param {FabricObject} fabricObject the fabric object that is interested in the action\n * @return {String} a valid css string for the cursor\n */\nexport const skewCursorStyleHandler: ControlCursorCallback = (\n  eventData,\n  control,\n  fabricObject,\n  coord,\n) => {\n  if (control.x !== 0 && isLocked(fabricObject, 'lockSkewingY')) {\n    return NOT_ALLOWED_CURSOR;\n  }\n  if (control.y !== 0 && isLocked(fabricObject, 'lockSkewingX')) {\n    return NOT_ALLOWED_CURSOR;\n  }\n  const n = findCornerQuadrant(fabricObject, control, coord) % 4;\n  return `${skewMap[n]}-resize`;\n};\n\n/**\n * Since skewing is applied before scaling, calculations are done in a scaleless plane\n * @see https://github.com/fabricjs/fabric.js/pull/8380\n */\nfunction skewObject(\n  axis: TAxis,\n  { target, ex, ey, skewingSide, ...transform }: SkewTransform,\n  pointer: Point,\n) {\n  const { skew: skewKey } = AXIS_KEYS[axis],\n    offset = pointer\n      .subtract(new Point(ex, ey))\n      .divide(new Point(target.scaleX, target.scaleY))[axis],\n    skewingBefore = target[skewKey],\n    skewingStart = transform[skewKey],\n    shearingStart = Math.tan(degreesToRadians(skewingStart)),\n    // let a, b be the size of target\n    // let a' be the value of a after applying skewing\n    // then:\n    // a' = a + b * skewA => skewA = (a' - a) / b\n    // the value b is tricky since skewY is applied before skewX\n    b =\n      axis === 'y'\n        ? target._getTransformedDimensions({\n            scaleX: 1,\n            scaleY: 1,\n            // since skewY is applied before skewX, b (=width) is not affected by skewX\n            skewX: 0,\n          }).x\n        : target._getTransformedDimensions({\n            scaleX: 1,\n            scaleY: 1,\n          }).y;\n\n  const shearing =\n    (2 * offset * skewingSide) /\n      // we max out fractions to safeguard from asymptotic behavior\n      Math.max(b, 1) +\n    // add starting state\n    shearingStart;\n\n  const skewing = radiansToDegrees(Math.atan(shearing));\n\n  target.set(skewKey, skewing);\n  const changed = skewingBefore !== target[skewKey];\n\n  if (changed && axis === 'y') {\n    // we don't want skewing to affect scaleX\n    // so we factor it by the inverse skewing diff to make it seem unchanged to the viewer\n    const { skewX, scaleX } = target,\n      dimBefore = target._getTransformedDimensions({ skewY: skewingBefore }),\n      dimAfter = target._getTransformedDimensions(),\n      compensationFactor = skewX !== 0 ? dimBefore.x / dimAfter.x : 1;\n    compensationFactor !== 1 &&\n      target.set(SCALE_X, compensationFactor * scaleX);\n  }\n\n  return changed;\n}\n\n/**\n * Wrapped Action handler for skewing on a given axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nfunction skewHandler(\n  axis: TAxis,\n  eventData: TPointerEvent,\n  transform: Transform,\n  x: number,\n  y: number,\n) {\n  const { target } = transform,\n    {\n      counterAxis,\n      origin: originKey,\n      lockSkewing: lockSkewingKey,\n      skew: skewKey,\n      flip: flipKey,\n    } = AXIS_KEYS[axis];\n  if (isLocked(target, lockSkewingKey)) {\n    return false;\n  }\n\n  const { origin: counterOriginKey, flip: counterFlipKey } =\n      AXIS_KEYS[counterAxis],\n    counterOriginFactor =\n      resolveOrigin(transform[counterOriginKey]) *\n      (target[counterFlipKey] ? -1 : 1),\n    // if the counter origin is top/left (= -0.5) then we are skewing x/y values on the bottom/right side of target respectively.\n    // if the counter origin is bottom/right (= 0.5) then we are skewing x/y values on the top/left side of target respectively.\n    // skewing direction on the top/left side of target is OPPOSITE to the direction of the movement of the pointer,\n    // so we factor skewing direction by this value.\n    skewingSide = (-Math.sign(counterOriginFactor) *\n      (target[flipKey] ? -1 : 1)) as 1 | -1,\n    skewingDirection =\n      ((target[skewKey] === 0 &&\n        // in case skewing equals 0 we use the pointer offset from target center to determine the direction of skewing\n        getLocalPoint(transform, CENTER, CENTER, x, y)[axis] > 0) ||\n      // in case target has skewing we use that as the direction\n      target[skewKey] > 0\n        ? 1\n        : -1) * skewingSide,\n    // anchor to the opposite side of the skewing direction\n    // normalize value from [-1, 1] to origin value [0, 1]\n    origin = -skewingDirection * 0.5 + 0.5;\n\n  const finalHandler = wrapWithFireEvent<SkewTransform>(\n    SKEWING,\n    wrapWithFixedAnchor((eventData, transform, x, y) =>\n      skewObject(axis, transform, new Point(x, y)),\n    ),\n  );\n\n  return finalHandler(\n    eventData,\n    {\n      ...transform,\n      [originKey]: origin,\n      skewingSide,\n    },\n    x,\n    y,\n  );\n}\n\n/**\n * Wrapped Action handler for skewing on the X axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nexport const skewHandlerX: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  return skewHandler('x', eventData, transform, x, y);\n};\n\n/**\n * Wrapped Action handler for skewing on the Y axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nexport const skewHandlerY: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  return skewHandler('y', eventData, transform, x, y);\n};\n"],"names":["AXIS_KEYS","x","counterAxis","scale","SCALE_X","skew","SKEW_X","lockSkewing","origin","flip","y","SCALE_Y","SKEW_Y","skewMap","skewCursorStyleHandler","eventData","control","fabricObject","coord","isLocked","NOT_ALLOWED_CURSOR","n","findCornerQuadrant","skewObject","axis","_ref","pointer","target","ex","ey","skewingSide","transform","skewKey","offset","subtract","Point","divide","scaleX","scaleY","skewingBefore","skewingStart","shearingStart","Math","tan","degreesToRadians","b","_getTransformedDimensions","skewX","shearing","max","skewing","radiansToDegrees","atan","set","changed","dimBefore","skewY","dimAfter","compensationFactor","skewHandler","originKey","lockSkewingKey","flipKey","counterOriginKey","counterFlipKey","counterOriginFactor","resolveOrigin","sign","skewingDirection","getLocalPoint","CENTER","finalHandler","wrapWithFireEvent","SKEWING","wrapWithFixedAnchor","skewHandlerX","skewHandlerY"],"mappings":"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"}