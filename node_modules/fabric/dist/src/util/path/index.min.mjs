import{cache as t}from"../../cache.min.mjs";import{config as e}from"../../config.min.mjs";import{halfPI as n,PiBy180 as s}from"../../constants.min.mjs";import{cos as r}from"../misc/cos.min.mjs";import{multiplyTransformMatrices as a,transformPoint as o}from"../misc/matrix.min.mjs";import{sin as c}from"../misc/sin.min.mjs";import{toFixed as i}from"../misc/toFixed.min.mjs";import{Point as l}from"../../Point.min.mjs";import{rePathCommand as h,reArcCommandPoints as m}from"./regex.min.mjs";import{reNum as u}from"../../parser/constants.min.mjs";const f={m:"l",M:"L"},x=(t,e,n,s,a,o,i,l,h,m,u)=>{const f=r(t),x=c(t),p=r(e),y=c(e),g=n*a*p-s*o*y+i,M=s*a*p+n*o*y+l;return["C",m+h*(-n*a*x-s*o*f),u+h*(-s*a*x+n*o*f),g+h*(n*a*y+s*o*p),M+h*(s*a*y-n*o*p),g,M]},p=(t,e,n,s)=>{const r=Math.atan2(e,t),a=Math.atan2(s,n);return a>=r?a-r:2*Math.PI-(r-a)};function y(n,s,r,a,o,c,i,h){let m;if(e.cachesBoundsOfCurve&&(m=[...arguments].join(),t.boundsOfCurveCache[m]))return t.boundsOfCurveCache[m];const u=Math.sqrt,f=Math.abs,x=[],p=[[0,0],[0,0]];let y=6*n-12*r+6*o,g=-3*n+9*r-9*o+3*i,M=3*r-3*n;for(let t=0;t<2;++t){if(t>0&&(y=6*s-12*a+6*c,g=-3*s+9*a-9*c+3*h,M=3*a-3*s),f(g)<1e-12){if(f(y)<1e-12)continue;const t=-M/y;0<t&&t<1&&x.push(t);continue}const e=y*y-4*M*g;if(e<0)continue;const n=u(e),r=(-y+n)/(2*g);0<r&&r<1&&x.push(r);const o=(-y-n)/(2*g);0<o&&o<1&&x.push(o)}let d=x.length;const b=d,C=w(n,s,r,a,o,c,i,h);for(;d--;){const{x:t,y:e}=C(x[d]);p[0][d]=t,p[1][d]=e}p[0][b]=n,p[1][b]=s,p[0][b+1]=i,p[1][b+1]=h;const j=[new l(Math.min(...p[0]),Math.min(...p[1])),new l(Math.max(...p[0]),Math.max(...p[1]))];return e.cachesBoundsOfCurve&&(t.boundsOfCurveCache[m]=j),j}const g=(t,e,n)=>{let[a,o,i,l,h,m,u,f]=n;const y=((t,e,n,a,o,i,l)=>{if(0===n||0===a)return[];let h=0,m=0,u=0;const f=Math.PI,y=l*s,g=c(y),M=r(y),d=.5*(-M*t-g*e),w=.5*(-M*e+g*t),b=n**2,C=a**2,j=w**2,k=d**2,v=b*C-b*j-C*k;let L=Math.abs(n),q=Math.abs(a);if(v<0){const t=Math.sqrt(1-v/(b*C));L*=t,q*=t}else u=(o===i?-1:1)*Math.sqrt(v/(b*j+C*k));const Q=u*L*w/q,F=-u*q*d/L,Z=M*Q-g*F+.5*t,O=g*Q+M*F+.5*e;let P=p(1,0,(d-Q)/L,(w-F)/q),A=p((d-Q)/L,(w-F)/q,(-d-Q)/L,(-w-F)/q);0===i&&A>0?A-=2*f:1===i&&A<0&&(A+=2*f);const E=Math.ceil(Math.abs(A/f*2)),I=[],R=A/E,X=8/3*Math.sin(R/4)*Math.sin(R/4)/Math.sin(R/2);let Y=P+R;for(let t=0;t<E;t++)I[t]=x(P,Y,M,g,L,q,Z,O,X,h,m),h=I[t][5],m=I[t][6],P=Y,Y+=R;return I})(u-t,f-e,o,i,h,m,l);for(let n=0,s=y.length;n<s;n++)y[n][1]+=t,y[n][2]+=e,y[n][3]+=t,y[n][4]+=e,y[n][5]+=t,y[n][6]+=e;return y},M=t=>{let e=0,n=0,s=0,r=0;const a=[];let o,c=0,i=0;for(const l of t){const t=[...l];let h;switch(t[0]){case"l":t[1]+=e,t[2]+=n;case"L":e=t[1],n=t[2],h=["L",e,n];break;case"h":t[1]+=e;case"H":e=t[1],h=["L",e,n];break;case"v":t[1]+=n;case"V":n=t[1],h=["L",e,n];break;case"m":t[1]+=e,t[2]+=n;case"M":e=t[1],n=t[2],s=t[1],r=t[2],h=["M",e,n];break;case"c":t[1]+=e,t[2]+=n,t[3]+=e,t[4]+=n,t[5]+=e,t[6]+=n;case"C":c=t[3],i=t[4],e=t[5],n=t[6],h=["C",t[1],t[2],c,i,e,n];break;case"s":t[1]+=e,t[2]+=n,t[3]+=e,t[4]+=n;case"S":"C"===o?(c=2*e-c,i=2*n-i):(c=e,i=n),e=t[3],n=t[4],h=["C",c,i,t[1],t[2],e,n],c=h[3],i=h[4];break;case"q":t[1]+=e,t[2]+=n,t[3]+=e,t[4]+=n;case"Q":c=t[1],i=t[2],e=t[3],n=t[4],h=["Q",c,i,e,n];break;case"t":t[1]+=e,t[2]+=n;case"T":"Q"===o?(c=2*e-c,i=2*n-i):(c=e,i=n),e=t[1],n=t[2],h=["Q",c,i,e,n];break;case"a":t[6]+=e,t[7]+=n;case"A":g(e,n,t).forEach(t=>a.push(t)),e=t[6],n=t[7];break;case"z":case"Z":e=s,n=r,h=["Z"]}h?(a.push(h),o=h[0]):o=""}return a},d=(t,e,n,s)=>Math.sqrt((n-t)**2+(s-e)**2),w=(t,e,n,s,r,a,o,c)=>i=>{const h=i**3,m=(t=>3*t**2*(1-t))(i),u=(t=>3*t*(1-t)**2)(i),f=(t=>(1-t)**3)(i);return new l(o*h+r*m+n*u+t*f,c*h+a*m+s*u+e*f)},b=t=>t**2,C=t=>2*t*(1-t),j=t=>(1-t)**2,k=(t,e,n,s,r,a,o,c)=>i=>{const l=b(i),h=C(i),m=j(i),u=3*(m*(n-t)+h*(r-n)+l*(o-r)),f=3*(m*(s-e)+h*(a-s)+l*(c-a));return Math.atan2(f,u)},v=(t,e,n,s,r,a)=>o=>{const c=b(o),i=C(o),h=j(o);return new l(r*c+n*i+t*h,a*c+s*i+e*h)},L=(t,e,n,s,r,a)=>o=>{const c=1-o,i=2*(c*(n-t)+o*(r-n)),l=2*(c*(s-e)+o*(a-s));return Math.atan2(l,i)},q=(t,e,n)=>{let s=new l(e,n),r=0;for(let e=1;e<=100;e+=1){const n=t(e/100);r+=d(s.x,s.y,n.x,n.y),s=n}return r},Q=(t,e)=>{let n,s=0,r=0,a={x:t.x,y:t.y},o={...a},c=.01,i=0;const l=t.iterator,h=t.angleFinder;for(;r<e&&c>1e-4;)o=l(s),i=s,n=d(a.x,a.y,o.x,o.y),n+r>e?(s-=c,c/=2):(a=o,s+=c,r+=n);return{...o,angle:h(i)}},F=t=>{let e,n,s=0,r=0,a=0,o=0,c=0;const i=[];for(const l of t){const t={x:r,y:a,command:l[0],length:0};switch(l[0]){case"M":n=t,n.x=o=r=l[1],n.y=c=a=l[2];break;case"L":n=t,n.length=d(r,a,l[1],l[2]),r=l[1],a=l[2];break;case"C":e=w(r,a,l[1],l[2],l[3],l[4],l[5],l[6]),n=t,n.iterator=e,n.angleFinder=k(r,a,l[1],l[2],l[3],l[4],l[5],l[6]),n.length=q(e,r,a),r=l[5],a=l[6];break;case"Q":e=v(r,a,l[1],l[2],l[3],l[4]),n=t,n.iterator=e,n.angleFinder=L(r,a,l[1],l[2],l[3],l[4]),n.length=q(e,r,a),r=l[3],a=l[4];break;case"Z":n=t,n.destX=o,n.destY=c,n.length=d(r,a,o,c),r=o,a=c}s+=n.length,i.push(n)}return i.push({length:s,x:r,y:a}),i},Z=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:F(t),s=0;for(;e-n[s].length>0&&s<n.length-2;)e-=n[s].length,s++;const r=n[s],a=e/r.length,o=t[s];switch(r.command){case"M":return{x:r.x,y:r.y,angle:0};case"Z":return{...new l(r.x,r.y).lerp(new l(r.destX,r.destY),a),angle:Math.atan2(r.destY-r.y,r.destX-r.x)};case"L":return{...new l(r.x,r.y).lerp(new l(o[1],o[2]),a),angle:Math.atan2(o[2]-r.y,o[1]-r.x)};case"C":case"Q":return Q(r,e)}},O=new RegExp(h,"gi"),P=new RegExp(m,"g"),A=new RegExp(u,"gi"),E={m:2,l:2,h:1,v:1,c:6,s:4,q:4,t:2,a:7},I=t=>{var e;const n=[],s=null!==(e=t.match(O))&&void 0!==e?e:[];for(const t of s){const e=t[0];if("z"===e||"Z"===e){n.push([e]);continue}const s=E[e.toLowerCase()];let r=[];if("a"===e||"A"===e){P.lastIndex=0;for(let e=null;e=P.exec(t);)r.push(...e.slice(1))}else r=t.match(A)||[];for(let t=0;t<r.length;t+=s){const a=new Array(s),o=f[e];a[0]=t>0&&o?o:e;for(let e=0;e<s;e++)a[e+1]=parseFloat(r[t+e]);n.push(a)}}return n},R=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=new l(t[0]),s=new l(t[1]),r=1,a=0;const o=[],c=t.length,i=c>2;let h;for(i&&(r=t[2].x<s.x?-1:t[2].x===s.x?0:1,a=t[2].y<s.y?-1:t[2].y===s.y?0:1),o.push(["M",n.x-r*e,n.y-a*e]),h=1;h<c;h++){if(!n.eq(s)){const t=n.midPointFrom(s);o.push(["Q",n.x,n.y,t.x,t.y])}n=t[h],h+1<t.length&&(s=t[h+1])}return i&&(r=n.x>t[h-2].x?1:n.x===t[h-2].x?0:-1,a=n.y>t[h-2].y?1:n.y===t[h-2].y?0:-1),o.push(["L",n.x+r*e,n.y+a*e]),o},X=(t,e,n)=>(n&&(e=a(e,[1,0,0,1,-n.x,-n.y])),t.map(t=>{const n=[...t];for(let s=1;s<t.length-1;s+=2){const{x:r,y:a}=o({x:t[s],y:t[s+1]},e);n[s]=r,n[s+1]=a}return n})),Y=(t,e)=>{const s=2*Math.PI/t;let a=-n;t%2==0&&(a+=s/2);const o=new Array(t+1);for(let n=0;n<t;n++){const t=n*s+a,{x:i,y:h}=new l(r(t),c(t)).scalarMultiply(e);o[n]=[0===n?"M":"L",i,h]}return o[t]=["Z"],o},z=(t,e)=>t.map(t=>t.map((t,n)=>0===n||void 0===e?t:i(t,e)).join(" ")).join(" ");export{g as fromArcToBeziers,y as getBoundsOfCurve,F as getPathSegmentsInfo,Z as getPointOnPath,Y as getRegularPolygonPath,R as getSmoothPathFromPoints,z as joinPath,M as makePathSimpler,I as parsePath,X as transformPath};
//# sourceMappingURL=index.min.mjs.map
