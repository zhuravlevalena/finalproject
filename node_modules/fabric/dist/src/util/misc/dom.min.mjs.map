{"version":3,"file":"dom.min.mjs","sources":["../../../../src/util/misc/dom.ts"],"sourcesContent":["import { getFabricDocument } from '../../env';\nimport type { ImageFormat, TSize } from '../../typedefs';\nimport { FabricError } from '../internals/console';\n/**\n * Creates canvas element\n * @return {CanvasElement} initialized canvas element\n */\nexport const createCanvasElement = (): HTMLCanvasElement => {\n  const element = getFabricDocument().createElement('canvas');\n  if (!element || typeof element.getContext === 'undefined') {\n    throw new FabricError('Failed to create `canvas` element');\n  }\n  return element;\n};\n\n/**\n * Creates image element (works on client and node)\n * @return {HTMLImageElement} HTML image element\n */\nexport const createImage = (): HTMLImageElement =>\n  getFabricDocument().createElement('img');\n\n/**\n * Creates a canvas element that is a copy of another and is also painted\n * @param {CanvasElement} canvas to copy size and content of\n * @return {CanvasElement} initialized canvas element\n */\nexport const copyCanvasElement = (\n  canvas: HTMLCanvasElement,\n): HTMLCanvasElement => {\n  const newCanvas = createCanvasElementFor(canvas);\n  newCanvas.getContext('2d')?.drawImage(canvas, 0, 0);\n  return newCanvas;\n};\n\n/**\n * Creates a canvas element as big as another\n * @param {CanvasElement} canvas to copy size and content of\n * @return {CanvasElement} initialized canvas element\n */\nexport const createCanvasElementFor = (\n  canvas: HTMLCanvasElement | ImageData | HTMLImageElement | TSize,\n): HTMLCanvasElement => {\n  const newCanvas = createCanvasElement();\n  newCanvas.width = canvas.width;\n  newCanvas.height = canvas.height;\n  return newCanvas;\n};\n\n/**\n * since 2.6.0 moved from canvas instance to utility.\n * possibly useless\n * @param {CanvasElement} canvasEl to copy size and content of\n * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too\n * @param {number} quality <= 1 and > 0\n * @return {String} data url\n */\nexport const toDataURL = (\n  canvasEl: HTMLCanvasElement,\n  format: ImageFormat,\n  quality: number,\n) => canvasEl.toDataURL(`image/${format}`, quality);\n\nexport const isHTMLCanvas = (\n  canvas?: HTMLCanvasElement | string,\n): canvas is HTMLCanvasElement => {\n  return !!canvas && (canvas as HTMLCanvasElement).getContext !== undefined;\n};\n\nexport const toBlob = (\n  canvasEl: HTMLCanvasElement,\n  format?: ImageFormat,\n  quality?: number,\n): Promise<Blob | null> =>\n  new Promise((resolve, _) => {\n    canvasEl.toBlob(resolve, `image/${format}`, quality);\n  });\n"],"names":["createCanvasElement","element","getFabricDocument","createElement","getContext","FabricError","createImage","copyCanvasElement","canvas","_newCanvas$getContext","newCanvas","createCanvasElementFor","drawImage","width","height","toDataURL","canvasEl","format","quality","isHTMLCanvas","undefined","toBlob","Promise","resolve","_"],"mappings":"uHAOO,MAAMA,EAAsBA,KACjC,MAAMC,EAAUC,IAAoBC,cAAc,UAClD,IAAKF,QAAyC,IAAvBA,EAAQG,WAC7B,MAAM,IAAIC,EAAY,qCAExB,OAAOJ,GAOIK,EAAcA,IACzBJ,IAAoBC,cAAc,OAOvBI,EACXC,IACsB,IAAAC,EACtB,MAAMC,EAAYC,EAAuBH,GAEzC,OAD0B,QAA1BC,EAAAC,EAAUN,WAAW,iBAAKK,GAA1BA,EAA4BG,UAAUJ,EAAQ,EAAG,GAC1CE,GAQIC,EACXH,IAEA,MAAME,EAAYV,IAGlB,OAFAU,EAAUG,MAAQL,EAAOK,MACzBH,EAAUI,OAASN,EAAOM,OACnBJ,GAWIK,EAAYA,CACvBC,EACAC,EACAC,IACGF,EAASD,UAAU,SAASE,IAAUC,GAE9BC,EACXX,KAESA,QAAuDY,IAA5CZ,EAA6BJ,WAGtCiB,EAASA,CACpBL,EACAC,EACAC,IAEA,IAAII,QAAQ,CAACC,EAASC,KACpBR,EAASK,OAAOE,EAAS,SAASN,IAAUC"}