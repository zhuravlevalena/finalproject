{"version":3,"file":"parseCoords.min.mjs","sources":["../../../../src/gradient/parser/parseCoords.ts"],"sourcesContent":["import { isPercent } from '../../parser/percent';\nimport type { TSize } from '../../typedefs';\nimport type { GradientCoords, GradientType, GradientUnits } from '../typedefs';\nimport { parseGradientUnits, parseType } from './misc';\n\nfunction convertPercentUnitsToValues<\n  T extends GradientType,\n  K extends keyof GradientCoords<T>,\n>(\n  valuesToConvert: Record<K, string | number>,\n  { width, height, gradientUnits }: TSize & { gradientUnits: GradientUnits },\n) {\n  let finalValue;\n  return (Object.entries(valuesToConvert) as [K, string | number][]).reduce(\n    (acc, [prop, propValue]) => {\n      if (propValue === 'Infinity') {\n        finalValue = 1;\n      } else if (propValue === '-Infinity') {\n        finalValue = 0;\n      } else {\n        const isString = typeof propValue === 'string';\n        finalValue = isString ? parseFloat(propValue) : propValue;\n        if (isString && isPercent(propValue)) {\n          finalValue *= 0.01;\n          if (gradientUnits === 'pixels') {\n            // then we need to fix those percentages here in svg parsing\n            if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\n              finalValue *= width;\n            }\n            if (prop === 'y1' || prop === 'y2') {\n              finalValue *= height;\n            }\n          }\n        }\n      }\n      acc[prop] = finalValue;\n      return acc;\n    },\n    {} as Record<K, number>,\n  );\n}\n\nfunction getValue(el: SVGGradientElement, key: string) {\n  return el.getAttribute(key);\n}\n\nexport function parseLinearCoords(el: SVGGradientElement) {\n  return {\n    x1: getValue(el, 'x1') || 0,\n    y1: getValue(el, 'y1') || 0,\n    x2: getValue(el, 'x2') || '100%',\n    y2: getValue(el, 'y2') || 0,\n  };\n}\n\nexport function parseRadialCoords(el: SVGGradientElement) {\n  return {\n    x1: getValue(el, 'fx') || getValue(el, 'cx') || '50%',\n    y1: getValue(el, 'fy') || getValue(el, 'cy') || '50%',\n    r1: 0,\n    x2: getValue(el, 'cx') || '50%',\n    y2: getValue(el, 'cy') || '50%',\n    r2: getValue(el, 'r') || '50%',\n  };\n}\n\nexport function parseCoords(el: SVGGradientElement, size: TSize) {\n  return convertPercentUnitsToValues(\n    parseType(el) === 'linear' ? parseLinearCoords(el) : parseRadialCoords(el),\n    {\n      ...size,\n      gradientUnits: parseGradientUnits(el),\n    },\n  );\n}\n"],"names":["getValue","el","key","getAttribute","parseLinearCoords","x1","y1","x2","y2","parseRadialCoords","r1","r2","parseCoords","size","valuesToConvert","_ref","finalValue","width","height","gradientUnits","Object","entries","reduce","acc","_ref2","prop","propValue","isString","parseFloat","isPercent","convertPercentUnitsToValues","parseType","parseGradientUnits"],"mappings":"4HA0CA,SAASA,EAASC,EAAwBC,GACxC,OAAOD,EAAGE,aAAaD,EACzB,CAEO,SAASE,EAAkBH,GAChC,MAAO,CACLI,GAAIL,EAASC,EAAI,OAAS,EAC1BK,GAAIN,EAASC,EAAI,OAAS,EAC1BM,GAAIP,EAASC,EAAI,OAAS,OAC1BO,GAAIR,EAASC,EAAI,OAAS,EAE9B,CAEO,SAASQ,EAAkBR,GAChC,MAAO,CACLI,GAAIL,EAASC,EAAI,OAASD,EAASC,EAAI,OAAS,MAChDK,GAAIN,EAASC,EAAI,OAASD,EAASC,EAAI,OAAS,MAChDS,GAAI,EACJH,GAAIP,EAASC,EAAI,OAAS,MAC1BO,GAAIR,EAASC,EAAI,OAAS,MAC1BU,GAAIX,EAASC,EAAI,MAAQ,MAE7B,CAEO,SAASW,EAAYX,EAAwBY,GAClD,OA9DF,SAIEC,EAA2CC,GAE3C,IACIC,GAFJC,MAAEA,EAAKC,OAAEA,EAAMC,cAAEA,GAAyDJ,EAG1E,OAAQK,OAAOC,QAAQP,GAA4CQ,OACjE,CAACC,EAAGC,KAAwB,IAArBC,EAAMC,GAAUF,EACrB,GAAkB,aAAdE,EACFV,EAAa,OACR,GAAkB,cAAdU,EACTV,EAAa,MACR,CACL,MAAMW,EAAgC,iBAAdD,EACxBV,EAAaW,EAAWC,WAAWF,GAAaA,EAC5CC,GAAYE,EAAUH,KACxBV,GAAc,IACQ,WAAlBG,IAEW,OAATM,GAA0B,OAATA,GAA0B,OAATA,IACpCT,GAAcC,GAEH,OAATQ,GAA0B,OAATA,IACnBT,GAAcE,IAItB,CAEA,OADAK,EAAIE,GAAQT,EACLO,GAET,CAAA,EAEJ,CA2BSO,CACa,WAAlBC,EAAU9B,GAAmBG,EAAkBH,GAAMQ,EAAkBR,GACvE,IACKY,EACHM,cAAea,EAAmB/B,IAGxC"}