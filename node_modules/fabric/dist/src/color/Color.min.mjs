import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{normalizeWs as r}from"../util/internals/normalizeWhiteSpace.min.mjs";import{radiansToDegrees as e}from"../util/misc/radiansDegreesConversion.min.mjs";import{ColorNameMap as s}from"./color_map.min.mjs";import{reRGBa as o,reHSLa as n,reHex as i}from"./constants.min.mjs";import{rgb2Hsl as c,hexify as a,greyAverage as u,fromAlphaToFloat as m,hue2rgb as l}from"./util.min.mjs";class h{constructor(r){if(t(this,"isUnrecognised",!1),r)if(r instanceof h)this.setSource([...r._source]);else if(Array.isArray(r)){const[t,e,s,o=1]=r;this.setSource([t,e,s,o])}else this.setSource(this._tryParsingColor(r));else this.setSource([0,0,0,1])}_tryParsingColor(t){return(t=t.toLowerCase())in s&&(t=s[t]),"transparent"===t?[255,255,255,0]:h.sourceFromHex(t)||h.sourceFromRgb(t)||h.sourceFromHsl(t)||(this.isUnrecognised=!0)&&[0,0,0,1]}getSource(){return this._source}setSource(t){this._source=t}toRgb(){const[t,r,e]=this.getSource();return`rgb(${t},${r},${e})`}toRgba(){return`rgba(${this.getSource().join(",")})`}toHsl(){const[t,r,e]=c(...this.getSource());return`hsl(${t},${r}%,${e}%)`}toHsla(){const[t,r,e,s]=c(...this.getSource());return`hsla(${t},${r}%,${e}%,${s})`}toHex(){return this.toHexa().slice(0,6)}toHexa(){const[t,r,e,s]=this.getSource();return`${a(t)}${a(r)}${a(e)}${a(Math.round(255*s))}`}getAlpha(){return this.getSource()[3]}setAlpha(t){return this._source[3]=t,this}toGrayscale(){return this.setSource(u(this.getSource())),this}toBlackWhite(t){const[r,,,e]=u(this.getSource()),s=r<(t||127)?0:255;return this.setSource([s,s,s,e]),this}overlayWith(t){t instanceof h||(t=new h(t));const r=this.getSource(),e=t.getSource(),[s,o,n]=r.map((t,r)=>Math.round(.5*t+.5*e[r]));return this.setSource([s,o,n,r[3]]),this}static fromRgb(t){return h.fromRgba(t)}static fromRgba(t){return new h(h.sourceFromRgb(t))}static sourceFromRgb(t){const e=r(t).match(o());if(e){const[t,r,s]=e.slice(1,4).map(t=>{const r=parseFloat(t);return t.endsWith("%")?Math.round(2.55*r):r});return[t,r,s,m(e[4])]}}static fromHsl(t){return h.fromHsla(t)}static fromHsla(t){return new h(h.sourceFromHsl(t))}static sourceFromHsl(t){const e=r(t).match(n());if(!e)return;const s=(h.parseAngletoDegrees(e[1])%360+360)%360/360,o=parseFloat(e[2])/100,i=parseFloat(e[3])/100;let c,a,u;if(0===o)c=a=u=i;else{const t=i<=.5?i*(o+1):i+o-i*o,r=2*i-t;c=l(r,t,s+1/3),a=l(r,t,s),u=l(r,t,s-1/3)}return[Math.round(255*c),Math.round(255*a),Math.round(255*u),m(e[4])]}static fromHex(t){return new h(h.sourceFromHex(t))}static sourceFromHex(t){if(t.match(i())){const r=t.slice(t.indexOf("#")+1);let e;e=r.length<=4?r.split("").map(t=>t+t):r.match(/.{2}/g);const[s,o,n,i=255]=e.map(t=>parseInt(t,16));return[s,o,n,i/255]}}static parseAngletoDegrees(t){const r=t.toLowerCase(),s=parseFloat(r);return r.includes("rad")?e(s):r.includes("turn")?360*s:s}}export{h as Color};
//# sourceMappingURL=Color.min.mjs.map
