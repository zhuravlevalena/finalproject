{"version":3,"file":"Textbox.mjs","sources":["../../../src/shapes/Textbox.ts"],"sourcesContent":["import type { TClassProperties, TOptions } from '../typedefs';\nimport { IText } from './IText/IText';\nimport { classRegistry } from '../ClassRegistry';\nimport { createTextboxDefaultControls } from '../controls/commonControls';\nimport { JUSTIFY } from './Text/constants';\nimport type { TextStyleDeclaration } from './Text/StyledText';\nimport type { SerializedITextProps, ITextProps } from './IText/IText';\nimport type { ITextEvents } from './IText/ITextBehavior';\nimport type { TextLinesInfo } from './Text/Text';\nimport type { Control } from '../controls/Control';\n\n// @TODO: Many things here are configuration related and shouldn't be on the class nor prototype\n// regexes, list of properties that are not suppose to change by instances, magic consts.\n// this will be a separated effort\nexport const textboxDefaultValues: Partial<TClassProperties<Textbox>> = {\n  minWidth: 20,\n  dynamicMinWidth: 2,\n  lockScalingFlip: true,\n  noScaleCache: false,\n  _wordJoiners: /[ \\t\\r]/,\n  splitByGrapheme: false,\n};\n\nexport type GraphemeData = {\n  wordsData: {\n    word: string[];\n    width: number;\n  }[][];\n  largestWordWidth: number;\n};\n\nexport type StyleMap = Record<string, { line: number; offset: number }>;\n\n// @TODO this is not complete\ninterface UniqueTextboxProps {\n  minWidth: number;\n  splitByGrapheme: boolean;\n  dynamicMinWidth: number;\n  _wordJoiners: RegExp;\n}\n\nexport interface SerializedTextboxProps\n  extends SerializedITextProps,\n    Pick<UniqueTextboxProps, 'minWidth' | 'splitByGrapheme'> {}\n\nexport interface TextboxProps extends ITextProps, UniqueTextboxProps {}\n\n/**\n * Textbox class, based on IText, allows the user to resize the text rectangle\n * and wraps lines automatically. Textboxes have their Y scaling locked, the\n * user can only change width. Height is adjusted automatically based on the\n * wrapping of lines.\n */\nexport class Textbox<\n    Props extends TOptions<TextboxProps> = Partial<TextboxProps>,\n    SProps extends SerializedTextboxProps = SerializedTextboxProps,\n    EventSpec extends ITextEvents = ITextEvents,\n  >\n  extends IText<Props, SProps, EventSpec>\n  implements UniqueTextboxProps\n{\n  /**\n   * Minimum width of textbox, in pixels.\n   * @type Number\n   */\n  declare minWidth: number;\n\n  /**\n   * Minimum calculated width of a textbox, in pixels.\n   * fixed to 2 so that an empty textbox cannot go to 0\n   * and is still selectable without text.\n   * @type Number\n   */\n  declare dynamicMinWidth: number;\n\n  /**\n   * Use this boolean property in order to split strings that have no white space concept.\n   * this is a cheap way to help with chinese/japanese\n   * @type Boolean\n   * @since 2.6.0\n   */\n  declare splitByGrapheme: boolean;\n\n  declare _wordJoiners: RegExp;\n\n  declare _styleMap: StyleMap;\n\n  declare isWrapping: boolean;\n\n  static type = 'Textbox';\n\n  static textLayoutProperties = [...IText.textLayoutProperties, 'width'];\n\n  static ownDefaults = textboxDefaultValues;\n\n  static getDefaults(): Record<string, any> {\n    return {\n      ...super.getDefaults(),\n      ...Textbox.ownDefaults,\n    };\n  }\n\n  /**\n   * Constructor\n   * @param {String} text Text string\n   * @param {Object} [options] Options object\n   */\n  constructor(text: string, options?: Props) {\n    super(text, { ...Textbox.ownDefaults, ...options } as Props);\n  }\n\n  /**\n   * Creates the default control object.\n   * If you prefer to have on instance of controls shared among all objects\n   * make this function return an empty object and add controls to the ownDefaults object\n   */\n  static createControls(): { controls: Record<string, Control> } {\n    return { controls: createTextboxDefaultControls() };\n  }\n\n  /**\n   * Unlike superclass's version of this function, Textbox does not update\n   * its width.\n   * @private\n   * @override\n   */\n  initDimensions() {\n    if (!this.initialized) {\n      return;\n    }\n    this.isEditing && this.initDelayedCursor();\n    this._clearCache();\n    // clear dynamicMinWidth as it will be different after we re-wrap line\n    this.dynamicMinWidth = 0;\n    // wrap lines\n    this._styleMap = this._generateStyleMap(this._splitText());\n    // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\n    if (this.dynamicMinWidth > this.width) {\n      this._set('width', this.dynamicMinWidth);\n    }\n    if (this.textAlign.includes(JUSTIFY)) {\n      // once text is measured we need to make space fatter to make justified text.\n      this.enlargeSpaces();\n    }\n    // clear cache and re-calculate height\n    this.height = this.calcTextHeight();\n  }\n\n  /**\n   * Generate an object that translates the style object so that it is\n   * broken up by visual lines (new lines and automatic wrapping).\n   * The original text styles object is broken up by actual lines (new lines only),\n   * which is only sufficient for Text / IText\n   * @private\n   */\n  _generateStyleMap(textInfo: TextLinesInfo): StyleMap {\n    let realLineCount = 0,\n      realLineCharCount = 0,\n      charCount = 0;\n    const map: StyleMap = {};\n\n    for (let i = 0; i < textInfo.graphemeLines.length; i++) {\n      if (textInfo.graphemeText[charCount] === '\\n' && i > 0) {\n        realLineCharCount = 0;\n        charCount++;\n        realLineCount++;\n      } else if (\n        !this.splitByGrapheme &&\n        this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) &&\n        i > 0\n      ) {\n        // this case deals with space's that are removed from end of lines when wrapping\n        realLineCharCount++;\n        charCount++;\n      }\n\n      map[i] = { line: realLineCount, offset: realLineCharCount };\n\n      charCount += textInfo.graphemeLines[i].length;\n      realLineCharCount += textInfo.graphemeLines[i].length;\n    }\n\n    return map;\n  }\n\n  /**\n   * Returns true if object has a style property or has it on a specified line\n   * @param {Number} lineIndex\n   * @return {Boolean}\n   */\n  styleHas(property: keyof TextStyleDeclaration, lineIndex: number): boolean {\n    if (this._styleMap && !this.isWrapping) {\n      const map = this._styleMap[lineIndex];\n      if (map) {\n        lineIndex = map.line;\n      }\n    }\n    return super.styleHas(property, lineIndex);\n  }\n\n  /**\n   * Returns true if object has no styling or no styling in a line\n   * @param {Number} lineIndex , lineIndex is on wrapped lines.\n   * @return {Boolean}\n   */\n  isEmptyStyles(lineIndex: number): boolean {\n    if (!this.styles) {\n      return true;\n    }\n    let offset = 0,\n      nextLineIndex = lineIndex + 1,\n      nextOffset: number,\n      shouldLimit = false;\n    const map = this._styleMap[lineIndex],\n      mapNextLine = this._styleMap[lineIndex + 1];\n    if (map) {\n      lineIndex = map.line;\n      offset = map.offset;\n    }\n    if (mapNextLine) {\n      nextLineIndex = mapNextLine.line;\n      shouldLimit = nextLineIndex === lineIndex;\n      nextOffset = mapNextLine.offset;\n    }\n    const obj =\n      typeof lineIndex === 'undefined'\n        ? this.styles\n        : { line: this.styles[lineIndex] };\n    for (const p1 in obj) {\n      for (const p2 in obj[p1]) {\n        const p2Number = parseInt(p2, 10);\n        if (p2Number >= offset && (!shouldLimit || p2Number < nextOffset!)) {\n          for (const p3 in obj[p1][p2]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @protected\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {TextStyleDeclaration} a style object reference to the existing one or a new empty object when undefined\n   */\n  _getStyleDeclaration(\n    lineIndex: number,\n    charIndex: number,\n  ): TextStyleDeclaration {\n    if (this._styleMap && !this.isWrapping) {\n      const map = this._styleMap[lineIndex];\n      if (!map) {\n        return {};\n      }\n      lineIndex = map.line;\n      charIndex = map.offset + charIndex;\n    }\n    return super._getStyleDeclaration(lineIndex, charIndex);\n  }\n\n  /**\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @param {Object} style\n   * @private\n   */\n  protected _setStyleDeclaration(\n    lineIndex: number,\n    charIndex: number,\n    style: object,\n  ) {\n    const map = this._styleMap[lineIndex];\n    super._setStyleDeclaration(map.line, map.offset + charIndex, style);\n  }\n\n  /**\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @private\n   */\n  protected _deleteStyleDeclaration(lineIndex: number, charIndex: number) {\n    const map = this._styleMap[lineIndex];\n    super._deleteStyleDeclaration(map.line, map.offset + charIndex);\n  }\n\n  /**\n   * probably broken need a fix\n   * Returns the real style line that correspond to the wrapped lineIndex line\n   * Used just to verify if the line does exist or not.\n   * @param {Number} lineIndex\n   * @returns {Boolean} if the line exists or not\n   * @private\n   */\n  protected _getLineStyle(lineIndex: number): boolean {\n    const map = this._styleMap[lineIndex];\n    return !!this.styles[map.line];\n  }\n\n  /**\n   * Set the line style to an empty object so that is initialized\n   * @param {Number} lineIndex\n   * @param {Object} style\n   * @private\n   */\n  protected _setLineStyle(lineIndex: number) {\n    const map = this._styleMap[lineIndex];\n    super._setLineStyle(map.line);\n  }\n\n  /**\n   * Wraps text using the 'width' property of Textbox. First this function\n   * splits text on newlines, so we preserve newlines entered by the user.\n   * Then it wraps each line using the width of the Textbox by calling\n   * _wrapLine().\n   * @param {Array} lines The string array of text that is split into lines\n   * @param {Number} desiredWidth width you want to wrap to\n   * @returns {Array} Array of lines\n   */\n  _wrapText(lines: string[], desiredWidth: number): string[][] {\n    this.isWrapping = true;\n    // extract all thewords and the widths to optimally wrap lines.\n    const data = this.getGraphemeDataForRender(lines);\n    const wrapped: string[][] = [];\n    for (let i = 0; i < data.wordsData.length; i++) {\n      wrapped.push(...this._wrapLine(i, desiredWidth, data));\n    }\n    this.isWrapping = false;\n    return wrapped;\n  }\n\n  /**\n   * For each line of text terminated by an hard line stop,\n   * measure each word width and extract the largest word from all.\n   * The returned words here are the one that at the end will be rendered.\n   * @param {string[]} lines the lines we need to measure\n   *\n   */\n  getGraphemeDataForRender(lines: string[]): GraphemeData {\n    const splitByGrapheme = this.splitByGrapheme,\n      infix = splitByGrapheme ? '' : ' ';\n\n    let largestWordWidth = 0;\n\n    const data = lines.map((line, lineIndex) => {\n      let offset = 0;\n      const wordsOrGraphemes = splitByGrapheme\n        ? this.graphemeSplit(line)\n        : this.wordSplit(line);\n\n      if (wordsOrGraphemes.length === 0) {\n        return [{ word: [], width: 0 }];\n      }\n\n      return wordsOrGraphemes.map((word: string) => {\n        // if using splitByGrapheme words are already in graphemes.\n        const graphemeArray = splitByGrapheme\n          ? [word]\n          : this.graphemeSplit(word);\n        const width = this._measureWord(graphemeArray, lineIndex, offset);\n        largestWordWidth = Math.max(width, largestWordWidth);\n        offset += graphemeArray.length + infix.length;\n        return { word: graphemeArray, width };\n      });\n    });\n\n    return {\n      wordsData: data,\n      largestWordWidth,\n    };\n  }\n\n  /**\n   * Helper function to measure a string of text, given its lineIndex and charIndex offset\n   * It gets called when charBounds are not available yet.\n   * Override if necessary\n   * Use with {@link Textbox#wordSplit}\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {String} text\n   * @param {number} lineIndex\n   * @param {number} charOffset\n   * @returns {number}\n   */\n  _measureWord(word: string[], lineIndex: number, charOffset = 0): number {\n    let width = 0,\n      prevGrapheme;\n    const skipLeft = true;\n    for (let i = 0, len = word.length; i < len; i++) {\n      const box = this._getGraphemeBox(\n        word[i],\n        lineIndex,\n        i + charOffset,\n        prevGrapheme,\n        skipLeft,\n      );\n      width += box.kernedWidth;\n      prevGrapheme = word[i];\n    }\n    return width;\n  }\n\n  /**\n   * Override this method to customize word splitting\n   * Use with {@link Textbox#_measureWord}\n   * @param {string} value\n   * @returns {string[]} array of words\n   */\n  wordSplit(value: string): string[] {\n    return value.split(this._wordJoiners);\n  }\n\n  /**\n   * Wraps a line of text using the width of the Textbox as desiredWidth\n   * and leveraging the known width o words from GraphemeData\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} desiredWidth width you want to wrap the line to\n   * @param {GraphemeData} graphemeData an object containing all the lines' words width.\n   * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n   * @returns {Array} Array of line(s) into which the given text is wrapped\n   * to.\n   */\n  _wrapLine(\n    lineIndex: number,\n    desiredWidth: number,\n    { largestWordWidth, wordsData }: GraphemeData,\n    reservedSpace = 0,\n  ): string[][] {\n    const additionalSpace = this._getWidthOfCharSpacing(),\n      splitByGrapheme = this.splitByGrapheme,\n      graphemeLines = [],\n      infix = splitByGrapheme ? '' : ' ';\n\n    let lineWidth = 0,\n      line: string[] = [],\n      // spaces in different languages?\n      offset = 0,\n      infixWidth = 0,\n      lineJustStarted = true;\n\n    desiredWidth -= reservedSpace;\n\n    const maxWidth = Math.max(\n      desiredWidth,\n      largestWordWidth,\n      this.dynamicMinWidth,\n    );\n    // layout words\n    const data = wordsData[lineIndex];\n    offset = 0;\n    let i;\n    for (i = 0; i < data.length; i++) {\n      const { word, width: wordWidth } = data[i];\n      offset += word.length;\n\n      lineWidth += infixWidth + wordWidth - additionalSpace;\n      if (lineWidth > maxWidth && !lineJustStarted) {\n        graphemeLines.push(line);\n        line = [];\n        lineWidth = wordWidth;\n        lineJustStarted = true;\n      } else {\n        lineWidth += additionalSpace;\n      }\n\n      if (!lineJustStarted && !splitByGrapheme) {\n        line.push(infix);\n      }\n      line = line.concat(word);\n\n      infixWidth = splitByGrapheme\n        ? 0\n        : this._measureWord([infix], lineIndex, offset);\n      offset++;\n      lineJustStarted = false;\n    }\n\n    i && graphemeLines.push(line);\n\n    // TODO: this code is probably not necessary anymore.\n    // it can be moved out of this function since largestWordWidth is now\n    // known in advance\n    if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {\n      this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;\n    }\n    return graphemeLines;\n  }\n\n  /**\n   * Detect if the text line is ended with an hard break\n   * text and itext do not have wrapping, return false\n   * @param {Number} lineIndex text to split\n   * @return {Boolean}\n   */\n  isEndOfWrapping(lineIndex: number): boolean {\n    if (!this._styleMap[lineIndex + 1]) {\n      // is last line, return true;\n      return true;\n    }\n    if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {\n      // this is last line before a line break, return true;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Detect if a line has a linebreak and so we need to account for it when moving\n   * and counting style.\n   * This is important only for splitByGrapheme at the end of wrapping.\n   * If we are not wrapping the offset is always 1\n   * @return Number\n   */\n  missingNewlineOffset(lineIndex: number, skipWrapping?: boolean): 0 | 1 {\n    if (this.splitByGrapheme && !skipWrapping) {\n      return this.isEndOfWrapping(lineIndex) ? 1 : 0;\n    }\n    return 1;\n  }\n\n  /**\n   * Gets lines of text to render in the Textbox. This function calculates\n   * text wrapping on the fly every time it is called.\n   * @param {String} text text to split\n   * @returns {Array} Array of lines in the Textbox.\n   * @override\n   */\n  _splitTextIntoLines(text: string) {\n    const newText = super._splitTextIntoLines(text),\n      graphemeLines = this._wrapText(newText.lines, this.width),\n      lines = new Array(graphemeLines.length);\n    for (let i = 0; i < graphemeLines.length; i++) {\n      lines[i] = graphemeLines[i].join('');\n    }\n    newText.lines = lines;\n    newText.graphemeLines = graphemeLines;\n    return newText;\n  }\n\n  getMinWidth() {\n    return Math.max(this.minWidth, this.dynamicMinWidth);\n  }\n\n  _removeExtraneousStyles() {\n    const linesToKeep = new Map();\n    for (const prop in this._styleMap) {\n      const propNumber = parseInt(prop, 10);\n      if (this._textLines[propNumber]) {\n        const lineIndex = this._styleMap[prop].line;\n        linesToKeep.set(`${lineIndex}`, true);\n      }\n    }\n    for (const prop in this.styles) {\n      if (!linesToKeep.has(prop)) {\n        delete this.styles[prop];\n      }\n    }\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} object representation of an instance\n   */\n  toObject<\n    T extends Omit<Props & TClassProperties<this>, keyof SProps>,\n    K extends keyof T = never,\n  >(propertiesToInclude: K[] = []): Pick<T, K> & SProps {\n    return super.toObject<T, K>([\n      'minWidth',\n      'splitByGrapheme',\n      ...propertiesToInclude,\n    ] as K[]);\n  }\n}\n\nclassRegistry.setClass(Textbox);\n"],"names":["textboxDefaultValues","minWidth","dynamicMinWidth","lockScalingFlip","noScaleCache","_wordJoiners","splitByGrapheme","Textbox","IText","getDefaults","ownDefaults","constructor","text","options","createControls","controls","createTextboxDefaultControls","initDimensions","initialized","isEditing","initDelayedCursor","_clearCache","_styleMap","_generateStyleMap","_splitText","width","_set","textAlign","includes","JUSTIFY","enlargeSpaces","height","calcTextHeight","textInfo","realLineCount","realLineCharCount","charCount","map","i","graphemeLines","length","graphemeText","_reSpaceAndTab","test","line","offset","styleHas","property","lineIndex","isWrapping","isEmptyStyles","styles","nextLineIndex","nextOffset","shouldLimit","mapNextLine","obj","p1","p2","p2Number","parseInt","p3","_getStyleDeclaration","charIndex","_setStyleDeclaration","style","_deleteStyleDeclaration","_getLineStyle","_setLineStyle","_wrapText","lines","desiredWidth","data","getGraphemeDataForRender","wrapped","wordsData","push","_wrapLine","infix","largestWordWidth","wordsOrGraphemes","graphemeSplit","wordSplit","word","graphemeArray","_measureWord","Math","max","charOffset","arguments","undefined","prevGrapheme","skipLeft","len","box","_getGraphemeBox","kernedWidth","value","split","_ref","reservedSpace","additionalSpace","_getWidthOfCharSpacing","lineWidth","infixWidth","lineJustStarted","maxWidth","wordWidth","concat","isEndOfWrapping","missingNewlineOffset","skipWrapping","_splitTextIntoLines","newText","Array","join","getMinWidth","_removeExtraneousStyles","linesToKeep","Map","prop","propNumber","_textLines","set","has","toObject","propertiesToInclude","_defineProperty","textLayoutProperties","classRegistry","setClass"],"mappings":"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"}