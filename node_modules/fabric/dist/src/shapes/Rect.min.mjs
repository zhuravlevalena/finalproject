import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{kRect as e}from"../constants.min.mjs";import{SHARED_ATTRIBUTES as r}from"../parser/attributes.min.mjs";import{parseAttributes as i}from"../parser/parseAttributes.min.mjs";import{classRegistry as s}from"../ClassRegistry.min.mjs";import{FabricObject as o}from"./Object/FabricObject.min.mjs";import{cacheProperties as n}from"./Object/defaultValues.min.mjs";const h={rx:0,ry:0},m=["rx","ry"];class a extends o{static getDefaults(){return{...super.getDefaults(),...a.ownDefaults}}constructor(t){super(),Object.assign(this,a.ownDefaults),this.setOptions(t),this._initRxRy()}_initRxRy(){const{rx:t,ry:e}=this;t&&!e?this.ry=t:e&&!t&&(this.rx=e)}_render(t){const{width:r,height:i}=this,s=-r/2,o=-i/2,n=this.rx?Math.min(this.rx,r/2):0,h=this.ry?Math.min(this.ry,i/2):0,m=0!==n||0!==h;t.beginPath(),t.moveTo(s+n,o),t.lineTo(s+r-n,o),m&&t.bezierCurveTo(s+r-e*n,o,s+r,o+e*h,s+r,o+h),t.lineTo(s+r,o+i-h),m&&t.bezierCurveTo(s+r,o+i-e*h,s+r-e*n,o+i,s+r-n,o+i),t.lineTo(s+n,o+i),m&&t.bezierCurveTo(s+e*n,o+i,s,o+i-e*h,s,o+i-h),t.lineTo(s,o+h),m&&t.bezierCurveTo(s,o+e*h,s+e*n,o,s+n,o),t.closePath(),this._renderPaintInOrder(t)}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return super.toObject([...m,...t])}_toSVG(){const{width:t,height:e,rx:r,ry:i}=this;return["<rect ","COMMON_PARTS",`x="${-t/2}" y="${-e/2}" rx="${r}" ry="${i}" width="${t}" height="${e}" />\n`]}static async fromElement(t,e,r){const{left:s=0,top:o=0,width:n=0,height:h=0,visible:m=!0,...a}=i(t,this.ATTRIBUTE_NAMES,r);return new this({...e,...a,left:s,top:o,width:n,height:h,visible:Boolean(m&&n&&h)})}}t(a,"type","Rect"),t(a,"cacheProperties",[...n,...m]),t(a,"ownDefaults",h),t(a,"ATTRIBUTE_NAMES",[...r,"x","y","rx","ry","width","height"]),s.setClass(a),s.setSVGClass(a);export{a as Rect,h as rectDefaultValues};
//# sourceMappingURL=Rect.min.mjs.map
