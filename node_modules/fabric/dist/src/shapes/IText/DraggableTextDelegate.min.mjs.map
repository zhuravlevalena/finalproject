{"version":3,"file":"DraggableTextDelegate.min.mjs","sources":["../../../../src/shapes/IText/DraggableTextDelegate.ts"],"sourcesContent":["import type {\n  DragEventData,\n  DropEventData,\n  TPointerEvent,\n} from '../../EventTypeDefs';\nimport { Point } from '../../Point';\nimport type { IText } from './IText';\nimport { setStyle } from '../../util/internals/dom_style';\nimport { cloneStyles } from '../../util/internals/cloneStyles';\nimport type { TextStyleDeclaration } from '../Text/StyledText';\nimport { getDocumentFromElement } from '../../util/dom_misc';\nimport { CHANGED, NONE } from '../../constants';\n\n/**\n * #### Dragging IText/Textbox Lifecycle\n * - {@link start} is called from `mousedown` {@link IText#_mouseDownHandler} and determines if dragging should start by testing {@link isPointerOverSelection}\n * - if true `mousedown` {@link IText#_mouseDownHandler} is blocked to keep selection\n * - if the pointer moves, canvas fires numerous mousemove {@link Canvas#_onMouseMove} that we make sure **aren't** prevented ({@link IText#shouldStartDragging}) in order for the window to start a drag session\n * - once/if the session starts canvas calls {@link onDragStart} on the active object to determine if dragging should occur\n * - canvas fires relevant drag events that are handled by the handlers defined in this scope\n * - {@link end} is called from `mouseup` {@link IText#mouseUpHandler}, blocking IText default click behavior\n * - in case the drag session didn't occur, {@link end} handles a click, since logic to do so was blocked during `mousedown`\n */\nexport class DraggableTextDelegate {\n  readonly target: IText;\n  private __mouseDownInPlace = false;\n  private __dragStartFired = false;\n  private __isDraggingOver = false;\n  private __dragStartSelection?: {\n    selectionStart: number;\n    selectionEnd: number;\n  };\n  private __dragImageDisposer?: VoidFunction;\n  private _dispose?: () => void;\n\n  constructor(target: IText) {\n    this.target = target;\n    const disposers = [\n      this.target.on('dragenter', this.dragEnterHandler.bind(this)),\n      this.target.on('dragover', this.dragOverHandler.bind(this)),\n      this.target.on('dragleave', this.dragLeaveHandler.bind(this)),\n      this.target.on('dragend', this.dragEndHandler.bind(this)),\n      this.target.on('drop', this.dropHandler.bind(this)),\n    ];\n    this._dispose = () => {\n      disposers.forEach((d) => d());\n      this._dispose = undefined;\n    };\n  }\n\n  isPointerOverSelection(e: TPointerEvent) {\n    const target = this.target;\n    const newSelection = target.getSelectionStartFromPointer(e);\n    return (\n      target.isEditing &&\n      newSelection >= target.selectionStart &&\n      newSelection <= target.selectionEnd &&\n      target.selectionStart < target.selectionEnd\n    );\n  }\n\n  /**\n   * @public override this method to disable dragging and default to mousedown logic\n   */\n  start(e: TPointerEvent) {\n    return (this.__mouseDownInPlace = this.isPointerOverSelection(e));\n  }\n\n  /**\n   * @public override this method to disable dragging without discarding selection\n   */\n  isActive() {\n    return this.__mouseDownInPlace;\n  }\n\n  /**\n   * Ends interaction and sets cursor in case of a click\n   * @returns true if was active\n   */\n  end(e: TPointerEvent) {\n    const active = this.isActive();\n    if (active && !this.__dragStartFired) {\n      // mousedown has been blocked since `active` is true => cursor has not been set.\n      // `__dragStartFired` is false => dragging didn't occur, pointer didn't move and is over selection.\n      // meaning this is actually a click, `active` is a false positive.\n      this.target.setCursorByClick(e);\n      this.target.initDelayedCursor(true);\n    }\n    this.__mouseDownInPlace = false;\n    this.__dragStartFired = false;\n    this.__isDraggingOver = false;\n    return active;\n  }\n\n  getDragStartSelection() {\n    return this.__dragStartSelection;\n  }\n\n  /**\n   * Override to customize the drag image\n   * https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/setDragImage\n   */\n  setDragImage(\n    e: DragEvent,\n    {\n      selectionStart,\n      selectionEnd,\n    }: {\n      selectionStart: number;\n      selectionEnd: number;\n    },\n  ) {\n    const target = this.target;\n    const canvas = target.canvas!;\n    const flipFactor = new Point(target.flipX ? -1 : 1, target.flipY ? -1 : 1);\n    const boundaries = target._getCursorBoundaries(selectionStart);\n    const selectionPosition = new Point(\n      boundaries.left + boundaries.leftOffset,\n      boundaries.top + boundaries.topOffset,\n    ).multiply(flipFactor);\n    const pos = selectionPosition.transform(target.calcTransformMatrix());\n    const pointer = canvas.getScenePoint(e);\n    const diff = pointer.subtract(pos);\n    const retinaScaling = target.getCanvasRetinaScaling();\n    const bbox = target.getBoundingRect();\n    const correction = pos.subtract(new Point(bbox.left, bbox.top));\n    const vpt = canvas.viewportTransform;\n    const offset = correction.add(diff).transform(vpt, true);\n    //  prepare instance for drag image snapshot by making all non selected text invisible\n    const bgc = target.backgroundColor;\n    const styles = cloneStyles(target.styles);\n    target.backgroundColor = '';\n    const styleOverride = {\n      stroke: 'transparent',\n      fill: 'transparent',\n      textBackgroundColor: 'transparent',\n    };\n    target.setSelectionStyles(styleOverride, 0, selectionStart);\n    target.setSelectionStyles(styleOverride, selectionEnd, target.text.length);\n    target.dirty = true;\n    const dragImage = target.toCanvasElement({\n      enableRetinaScaling: canvas.enableRetinaScaling,\n      viewportTransform: true,\n    });\n    // restore values\n    target.backgroundColor = bgc;\n    target.styles = styles;\n    target.dirty = true;\n    //  position drag image offscreen\n    setStyle(dragImage, {\n      position: 'fixed',\n      left: `${-dragImage.width}px`,\n      border: NONE,\n      width: `${dragImage.width / retinaScaling}px`,\n      height: `${dragImage.height / retinaScaling}px`,\n    });\n    this.__dragImageDisposer && this.__dragImageDisposer();\n    this.__dragImageDisposer = () => {\n      dragImage.remove();\n    };\n    getDocumentFromElement(\n      (e.target || this.target.hiddenTextarea)! as HTMLElement,\n    ).body.appendChild(dragImage);\n    e.dataTransfer?.setDragImage(dragImage, offset.x, offset.y);\n  }\n\n  /**\n   * @returns {boolean} determines whether {@link target} should/shouldn't become a drag source\n   */\n  onDragStart(e: DragEvent): boolean {\n    this.__dragStartFired = true;\n    const target = this.target;\n    const active = this.isActive();\n    if (active && e.dataTransfer) {\n      const selection = (this.__dragStartSelection = {\n        selectionStart: target.selectionStart,\n        selectionEnd: target.selectionEnd,\n      });\n      const value = target._text\n        .slice(selection.selectionStart, selection.selectionEnd)\n        .join('');\n      const data = { text: target.text, value, ...selection };\n      e.dataTransfer.setData('text/plain', value);\n      e.dataTransfer.setData(\n        'application/fabric',\n        JSON.stringify({\n          value: value,\n          styles: target.getSelectionStyles(\n            selection.selectionStart,\n            selection.selectionEnd,\n            true,\n          ),\n        }),\n      );\n      e.dataTransfer.effectAllowed = 'copyMove';\n      this.setDragImage(e, data);\n    }\n    target.abortCursorAnimation();\n    return active;\n  }\n\n  /**\n   * use {@link targetCanDrop} to respect overriding\n   * @returns {boolean} determines whether {@link target} should/shouldn't become a drop target\n   */\n  canDrop(e: DragEvent): boolean {\n    if (\n      this.target.editable &&\n      !this.target.getActiveControl() &&\n      !e.defaultPrevented\n    ) {\n      if (this.isActive() && this.__dragStartSelection) {\n        //  drag source trying to drop over itself\n        //  allow dropping only outside of drag start selection\n        const index = this.target.getSelectionStartFromPointer(e);\n        const dragStartSelection = this.__dragStartSelection;\n        return (\n          index < dragStartSelection.selectionStart ||\n          index > dragStartSelection.selectionEnd\n        );\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * in order to respect overriding {@link IText#canDrop} we call that instead of calling {@link canDrop} directly\n   */\n  protected targetCanDrop(e: DragEvent) {\n    return this.target.canDrop(e);\n  }\n\n  dragEnterHandler({ e }: DragEventData) {\n    const canDrop = this.targetCanDrop(e);\n    if (!this.__isDraggingOver && canDrop) {\n      this.__isDraggingOver = true;\n    }\n  }\n\n  dragOverHandler(ev: DragEventData) {\n    const { e } = ev;\n    const canDrop = this.targetCanDrop(e);\n    if (!this.__isDraggingOver && canDrop) {\n      this.__isDraggingOver = true;\n    } else if (this.__isDraggingOver && !canDrop) {\n      //  drop state has changed\n      this.__isDraggingOver = false;\n    }\n    if (this.__isDraggingOver) {\n      //  can be dropped, inform browser\n      e.preventDefault();\n      //  inform event subscribers\n      ev.canDrop = true;\n      ev.dropTarget = this.target;\n    }\n  }\n\n  dragLeaveHandler() {\n    if (this.__isDraggingOver || this.isActive()) {\n      this.__isDraggingOver = false;\n    }\n  }\n\n  /**\n   * Override the `text/plain | application/fabric` types of {@link DragEvent#dataTransfer}\n   * in order to change the drop value or to customize styling respectively, by listening to the `drop:before` event\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#performing_a_drop\n   */\n  dropHandler(ev: DropEventData) {\n    const { e } = ev;\n    const didDrop = e.defaultPrevented;\n    this.__isDraggingOver = false;\n    // inform browser that the drop has been accepted\n    e.preventDefault();\n    let insert = e.dataTransfer?.getData('text/plain');\n    if (insert && !didDrop) {\n      const target = this.target;\n      const canvas = target.canvas!;\n      let insertAt = target.getSelectionStartFromPointer(e);\n      const { styles } = (\n        e.dataTransfer!.types.includes('application/fabric')\n          ? JSON.parse(e.dataTransfer!.getData('application/fabric'))\n          : {}\n      ) as { styles: TextStyleDeclaration[] };\n      const trailing = insert[Math.max(0, insert.length - 1)];\n      const selectionStartOffset = 0;\n      //  drag and drop in same instance\n      if (this.__dragStartSelection) {\n        const selectionStart = this.__dragStartSelection.selectionStart;\n        const selectionEnd = this.__dragStartSelection.selectionEnd;\n        if (insertAt > selectionStart && insertAt <= selectionEnd) {\n          insertAt = selectionStart;\n        } else if (insertAt > selectionEnd) {\n          insertAt -= selectionEnd - selectionStart;\n        }\n        target.removeChars(selectionStart, selectionEnd);\n        // prevent `dragend` from handling event\n        delete this.__dragStartSelection;\n      }\n      //  remove redundant line break\n      if (\n        target._reNewline.test(trailing) &&\n        (target._reNewline.test(target._text[insertAt]) ||\n          insertAt === target._text.length)\n      ) {\n        insert = insert.trimEnd();\n      }\n      //  inform subscribers\n      ev.didDrop = true;\n      ev.dropTarget = target;\n      //  finalize\n      target.insertChars(insert, styles, insertAt);\n      // can this part be moved in an outside event? andrea to check.\n      canvas.setActiveObject(target);\n      target.enterEditing(e);\n      target.selectionStart = Math.min(\n        insertAt + selectionStartOffset,\n        target._text.length,\n      );\n      target.selectionEnd = Math.min(\n        target.selectionStart + insert.length,\n        target._text.length,\n      );\n      target.hiddenTextarea!.value = target.text;\n      target._updateTextarea();\n      target.hiddenTextarea!.focus();\n      target.fire(CHANGED, {\n        index: insertAt + selectionStartOffset,\n        action: 'drop',\n      });\n      canvas.fire('text:changed', { target });\n      canvas.contextTopDirty = true;\n      canvas.requestRenderAll();\n    }\n  }\n\n  /**\n   * fired only on the drag source after drop (if occurred)\n   * handle changes to the drag source in case of a drop on another object or a cancellation\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#finishing_a_drag\n   */\n  dragEndHandler({ e }: DragEventData) {\n    if (this.isActive() && this.__dragStartFired) {\n      //  once the drop event finishes we check if we need to change the drag source\n      //  if the drag source received the drop we bail out since the drop handler has already handled logic\n      if (this.__dragStartSelection) {\n        const target = this.target;\n        const canvas = this.target.canvas!;\n        const { selectionStart, selectionEnd } = this.__dragStartSelection;\n        const dropEffect = e.dataTransfer?.dropEffect || NONE;\n        if (dropEffect === NONE) {\n          // pointer is back over selection\n          target.selectionStart = selectionStart;\n          target.selectionEnd = selectionEnd;\n          target._updateTextarea();\n          target.hiddenTextarea!.focus();\n        } else {\n          target.clearContextTop();\n          if (dropEffect === 'move') {\n            target.removeChars(selectionStart, selectionEnd);\n            target.selectionStart = target.selectionEnd = selectionStart;\n            target.hiddenTextarea &&\n              (target.hiddenTextarea.value = target.text);\n            target._updateTextarea();\n            target.fire(CHANGED, {\n              index: selectionStart,\n              action: 'dragend',\n            });\n            canvas.fire('text:changed', { target });\n            canvas.requestRenderAll();\n          }\n          target.exitEditing();\n        }\n      }\n    }\n\n    this.__dragImageDisposer && this.__dragImageDisposer();\n    delete this.__dragImageDisposer;\n    delete this.__dragStartSelection;\n    this.__isDraggingOver = false;\n  }\n\n  dispose() {\n    this._dispose && this._dispose();\n  }\n}\n"],"names":["DraggableTextDelegate","constructor","target","_defineProperty","this","disposers","on","dragEnterHandler","bind","dragOverHandler","dragLeaveHandler","dragEndHandler","dropHandler","_dispose","forEach","d","undefined","isPointerOverSelection","e","newSelection","getSelectionStartFromPointer","isEditing","selectionStart","selectionEnd","start","__mouseDownInPlace","isActive","end","active","__dragStartFired","setCursorByClick","initDelayedCursor","__isDraggingOver","getDragStartSelection","__dragStartSelection","setDragImage","_ref","_e$dataTransfer","canvas","flipFactor","Point","flipX","flipY","boundaries","_getCursorBoundaries","pos","left","leftOffset","top","topOffset","multiply","transform","calcTransformMatrix","diff","getScenePoint","subtract","retinaScaling","getCanvasRetinaScaling","bbox","getBoundingRect","correction","vpt","viewportTransform","offset","add","bgc","backgroundColor","styles","cloneStyles","styleOverride","stroke","fill","textBackgroundColor","setSelectionStyles","text","length","dirty","dragImage","toCanvasElement","enableRetinaScaling","setStyle","position","width","border","NONE","height","__dragImageDisposer","remove","getDocumentFromElement","hiddenTextarea","body","appendChild","dataTransfer","x","y","onDragStart","selection","value","_text","slice","join","data","setData","JSON","stringify","getSelectionStyles","effectAllowed","abortCursorAnimation","canDrop","editable","getActiveControl","defaultPrevented","index","dragStartSelection","targetCanDrop","_ref2","ev","preventDefault","dropTarget","_e$dataTransfer2","didDrop","insert","getData","insertAt","types","includes","parse","trailing","Math","max","selectionStartOffset","removeChars","_reNewline","test","trimEnd","insertChars","setActiveObject","enterEditing","min","_updateTextarea","focus","fire","CHANGED","action","contextTopDirty","requestRenderAll","_ref3","_e$dataTransfer3","dropEffect","clearContextTop","exitEditing","dispose"],"mappings":"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"}