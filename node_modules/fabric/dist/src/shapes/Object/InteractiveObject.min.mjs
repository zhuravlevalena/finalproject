import{defineProperty as t}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as r,ZERO as o}from"../../Point.min.mjs";import{FabricObject as s}from"./Object.min.mjs";import{degreesToRadians as e}from"../../util/misc/radiansDegreesConversion.min.mjs";import{createTranslateMatrix as i,createRotateMatrix as n,multiplyTransformMatrices as a,qrDecompose as l,calcDimensionsMatrix as c}from"../../util/misc/matrix.min.mjs";import{sizeAfterTransform as h}from"../../util/misc/objectTransforms.min.mjs";import{createObjectDefaultControls as d}from"../../controls/commonControls.min.mjs";import{interactiveObjectDefaultValues as C}from"./defaultValues.min.mjs";import{SCALE as u}from"../../constants.min.mjs";class m extends s{static getDefaults(){return{...super.getDefaults(),...m.ownDefaults}}constructor(t){super(),Object.assign(this,this.constructor.createControls(),m.ownDefaults),this.setOptions(t)}static createControls(){return{controls:d()}}_updateCacheCanvas(){const t=this.canvas;if(this.noScaleCache&&t&&t._currentTransform){const r=t._currentTransform,o=r.target,s=r.action;if(this===o&&s&&s.startsWith(u))return!1}return super._updateCacheCanvas()}getActiveControl(){const t=this.__corner;return t?{key:t,control:this.controls[t],coord:this.oCoords[t]}:void 0}findControl(t){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.hasControls||!this.canvas)return;this.__corner=void 0;const o=Object.entries(this.oCoords);for(let s=o.length-1;s>=0;s--){const[e,i]=o[s],n=this.controls[e];if(n.shouldActivate(e,this,t,r?i.touchCorner:i.corner))return this.__corner=e,{key:e,control:n,coord:this.oCoords[e]}}}calcOCoords(){const t=this.getViewportTransform(),r=this.getCenterPoint(),o=i(r.x,r.y),s=n({angle:this.getTotalAngle()-(this.group&&this.flipX?180:0)}),e=a(o,s),c=a(t,e),h=a(c,[1/t[0],0,0,1/t[3],0,0]),d=this.group?l(this.calcTransformMatrix()):void 0;d&&(d.scaleX=Math.abs(d.scaleX),d.scaleY=Math.abs(d.scaleY));const C=this._calculateCurrentDimensions(d),u={};return this.forEachControl((t,r)=>{const o=t.positionHandler(C,h,this,t);u[r]=Object.assign(o,this._calcCornerCoords(t,o))}),u}_calcCornerCoords(t,r){const o=this.getTotalAngle();return{corner:t.calcCornerCoords(o,this.cornerSize,r.x,r.y,!1,this),touchCorner:t.calcCornerCoords(o,this.touchCornerSize,r.x,r.y,!0,this)}}setCoords(){super.setCoords(),this.canvas&&(this.oCoords=this.calcOCoords())}forEachControl(t){for(const r in this.controls)t(this.controls[r],r,this)}drawSelectionBackground(t){if(!this.selectionBackgroundColor||this.canvas&&this.canvas._activeObject!==this)return;t.save();const r=this.getRelativeCenterPoint(),o=this._calculateCurrentDimensions(),s=this.getViewportTransform();t.translate(r.x,r.y),t.scale(1/s[0],1/s[3]),t.rotate(e(this.angle)),t.fillStyle=this.selectionBackgroundColor,t.fillRect(-o.x/2,-o.y/2,o.x,o.y),t.restore()}strokeBorders(t,r){t.strokeRect(-r.x/2,-r.y/2,r.x,r.y)}_drawBorders(t,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s={hasControls:this.hasControls,borderColor:this.borderColor,borderDashArray:this.borderDashArray,...o};t.save(),t.strokeStyle=s.borderColor,this._setLineDash(t,s.borderDashArray),this.strokeBorders(t,r),s.hasControls&&this.drawControlsConnectingLines(t,r),t.restore()}_renderControls(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{hasBorders:o,hasControls:s}=this,i={hasBorders:o,hasControls:s,...r},n=this.getViewportTransform(),c=i.hasBorders,h=i.hasControls,d=a(n,this.calcTransformMatrix()),C=l(d);t.save(),t.translate(C.translateX,C.translateY),t.lineWidth=this.borderScaleFactor,this.group===this.parent&&(t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1),this.flipX&&(C.angle-=180),t.rotate(e(this.group?C.angle:this.angle)),c&&this.drawBorders(t,C,r),h&&this.drawControls(t,r),t.restore()}drawBorders(t,s,e){let i;if(e&&e.forActiveSelection||this.group){const t=h(this.width,this.height,c(s)),e=this.isStrokeAccountedForInDimensions()?o:(this.strokeUniform?(new r).scalarAdd(this.canvas?this.canvas.getZoom():1):new r(s.scaleX,s.scaleY)).scalarMultiply(this.strokeWidth);i=t.add(e).scalarAdd(this.borderScaleFactor).scalarAdd(2*this.padding)}else i=this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);this._drawBorders(t,i,e)}drawControlsConnectingLines(t,r){let o=!1;t.beginPath(),this.forEachControl((s,e)=>{s.withConnection&&s.getVisibility(this,e)&&(o=!0,t.moveTo(s.x*r.x,s.y*r.y),t.lineTo(s.x*r.x+s.offsetX,s.y*r.y+s.offsetY))}),o&&t.stroke()}drawControls(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.save();const o=this.getCanvasRetinaScaling(),{cornerStrokeColor:s,cornerDashArray:e,cornerColor:i}=this,n={cornerStrokeColor:s,cornerDashArray:e,cornerColor:i,...r};t.setTransform(o,0,0,o,0,0),t.strokeStyle=t.fillStyle=n.cornerColor,this.transparentCorners||(t.strokeStyle=n.cornerStrokeColor),this._setLineDash(t,n.cornerDashArray),this.forEachControl((r,o)=>{if(r.getVisibility(this,o)){const s=this.oCoords[o];r.render(t,s.x,s.y,n,this)}}),t.restore()}isControlVisible(t){return this.controls[t]&&this.controls[t].getVisibility(this,t)}setControlVisible(t,r){this._controlsVisibility||(this._controlsVisibility={}),this._controlsVisibility[t]=r}setControlsVisibility(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object.entries(t).forEach(t=>{let[r,o]=t;return this.setControlVisible(r,o)})}clearContextTop(t){if(!this.canvas)return;const r=this.canvas.contextTop;if(!r)return;const o=this.canvas.viewportTransform;r.save(),r.transform(o[0],o[1],o[2],o[3],o[4],o[5]),this.transform(r);const s=this.width+4,e=this.height+4;return r.clearRect(-s/2,-e/2,s,e),t||r.restore(),r}onDeselect(t){return!1}onSelect(t){return!1}shouldStartDragging(t){return!1}onDragStart(t){return!1}canDrop(t){return!1}renderDragSourceEffect(t){}renderDropTargetEffect(t){}}t(m,"ownDefaults",C);export{m as InteractiveFabricObject};
//# sourceMappingURL=InteractiveObject.min.mjs.map
