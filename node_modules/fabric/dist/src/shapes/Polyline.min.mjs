import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{config as i}from"../config.min.mjs";import{SHARED_ATTRIBUTES as s}from"../parser/attributes.min.mjs";import{parseAttributes as e}from"../parser/parseAttributes.min.mjs";import{parsePointsAttribute as o}from"../parser/parsePointsAttribute.min.mjs";import{Point as n}from"../Point.min.mjs";import{classRegistry as r}from"../ClassRegistry.min.mjs";import{makeBoundingBoxFromPoints as h}from"../util/misc/boundingBoxFromPoints.min.mjs";import{calcDimensionsMatrix as m,transformPoint as p}from"../util/misc/matrix.min.mjs";import{projectStrokeOnPoints as a}from"../util/misc/projectStroke/index.min.mjs";import{degreesToRadians as l}from"../util/misc/radiansDegreesConversion.min.mjs";import{toFixed as f}from"../util/misc/toFixed.min.mjs";import{FabricObject as c}from"./Object/FabricObject.min.mjs";import{SKEW_X as u,SKEW_Y as d,LEFT as g,TOP as k,CENTER as w,SCALE_X as x,SCALE_Y as O}from"../constants.min.mjs";import{cacheProperties as j}from"./Object/defaultValues.min.mjs";const y={exactBoundingBox:!1};class B extends c{static getDefaults(){return{...super.getDefaults(),...B.ownDefaults}}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),t(this,"strokeDiff",void 0),Object.assign(this,B.ownDefaults),this.setOptions(s),this.points=i;const{left:e,top:o}=s;this.initialized=!0,this.setBoundingBox(!0),"number"==typeof e&&this.set(g,e),"number"==typeof o&&this.set(k,o)}isOpen(){return!0}_projectStrokeOnPoints(t){return a(this.points,t,this.isOpen())}_calcDimensions(t){t={scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,strokeLineCap:this.strokeLineCap,strokeLineJoin:this.strokeLineJoin,strokeMiterLimit:this.strokeMiterLimit,strokeUniform:this.strokeUniform,strokeWidth:this.strokeWidth,...t||{}};const i=this.exactBoundingBox?this._projectStrokeOnPoints(t).map(t=>t.projectedPoint):this.points;if(0===i.length)return{left:0,top:0,width:0,height:0,pathOffset:new n,strokeOffset:new n,strokeDiff:new n};const s=h(i),e=m({...t,scaleX:1,scaleY:1}),o=h(this.points.map(t=>p(t,e,!0))),r=new n(this.scaleX,this.scaleY);let a=s.left+s.width/2,f=s.top+s.height/2;return this.exactBoundingBox&&(a-=f*Math.tan(l(this.skewX)),f-=a*Math.tan(l(this.skewY))),{...s,pathOffset:new n(a,f),strokeOffset:new n(o.left,o.top).subtract(new n(s.left,s.top)).multiply(r),strokeDiff:new n(s.width,s.height).subtract(new n(o.width,o.height)).multiply(r)}}_findCenterFromElement(){const t=h(this.points);return new n(t.left+t.width/2,t.top+t.height/2)}setDimensions(){this.setBoundingBox()}setBoundingBox(t){const{left:i,top:s,width:e,height:o,pathOffset:r,strokeOffset:h,strokeDiff:m}=this._calcDimensions();this.set({width:e,height:o,pathOffset:r,strokeOffset:h,strokeDiff:m}),t&&this.setPositionByOrigin(new n(i+e/2,s+o/2),w,w)}isStrokeAccountedForInDimensions(){return this.exactBoundingBox}_getNonTransformedDimensions(){return this.exactBoundingBox?new n(this.width,this.height):super._getNonTransformedDimensions()}_getTransformedDimensions(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.exactBoundingBox){let r;if(Object.keys(t).some(t=>this.strokeUniform||this.constructor.layoutProperties.includes(t))){var i,s;const{width:e,height:o}=this._calcDimensions(t);r=new n(null!==(i=t.width)&&void 0!==i?i:e,null!==(s=t.height)&&void 0!==s?s:o)}else{var e,o;r=new n(null!==(e=t.width)&&void 0!==e?e:this.width,null!==(o=t.height)&&void 0!==o?o:this.height)}return r.multiply(new n(t.scaleX||this.scaleX,t.scaleY||this.scaleY))}return super._getTransformedDimensions(t)}_set(t,i){const s=this.initialized&&this[t]!==i,e=super._set(t,i);return this.exactBoundingBox&&s&&((t===x||t===O)&&this.strokeUniform&&this.constructor.layoutProperties.includes("strokeUniform")||this.constructor.layoutProperties.includes(t))&&this.setDimensions(),e}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return{...super.toObject(t),points:this.points.map(t=>{let{x:i,y:s}=t;return{x:i,y:s}})}}_toSVG(){const t=[],s=this.pathOffset.x,e=this.pathOffset.y,o=i.NUM_FRACTION_DIGITS;for(let i=0,n=this.points.length;i<n;i++)t.push(f(this.points[i].x-s,o),",",f(this.points[i].y-e,o)," ");return[`<${this.constructor.type.toLowerCase()} `,"COMMON_PARTS",`points="${t.join("")}" />\n`]}_render(t){const i=this.points.length,s=this.pathOffset.x,e=this.pathOffset.y;if(i&&!isNaN(this.points[i-1].y)){t.beginPath(),t.moveTo(this.points[0].x-s,this.points[0].y-e);for(let o=0;o<i;o++){const i=this.points[o];t.lineTo(i.x-s,i.y-e)}!this.isOpen()&&t.closePath(),this._renderPaintInOrder(t)}}complexity(){return this.points.length}static async fromElement(t,i,s){const n=o(t.getAttribute("points")),{left:r,top:h,...m}=e(t,this.ATTRIBUTE_NAMES,s);return new this(n,{...m,...i})}static fromObject(t){return this._fromObject(t,{extraParam:"points"})}}t(B,"ownDefaults",y),t(B,"type","Polyline"),t(B,"layoutProperties",[u,d,"strokeLineCap","strokeLineJoin","strokeMiterLimit","strokeWidth","strokeUniform","points"]),t(B,"cacheProperties",[...j,"points"]),t(B,"ATTRIBUTE_NAMES",[...s]),r.setClass(B),r.setSVGClass(B);export{B as Polyline,y as polylineDefaultValues};
//# sourceMappingURL=Polyline.min.mjs.map
