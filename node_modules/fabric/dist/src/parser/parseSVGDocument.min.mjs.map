{"version":3,"file":"parseSVGDocument.min.mjs","sources":["../../../src/parser/parseSVGDocument.ts"],"sourcesContent":["import { applyViewboxTransform } from './applyViewboxTransform';\nimport { svgValidTagNamesRegEx } from './constants';\nimport { hasInvalidAncestor } from './hasInvalidAncestor';\nimport { parseUseDirectives } from './parseUseDirectives';\nimport type { SVGParsingOutput, TSvgReviverCallback } from './typedefs';\nimport type { LoadImageOptions } from '../util/misc/objectEnlive';\nimport { ElementsParser } from './elements_parser';\nimport { log, SignalAbortedError } from '../util/internals/console';\nimport { getTagName } from './getTagName';\n\nconst isValidSvgTag = (el: Element) =>\n  svgValidTagNamesRegEx.test(getTagName(el));\n\nexport const createEmptyResponse = (): SVGParsingOutput => ({\n  objects: [],\n  elements: [],\n  options: {},\n  allElements: [],\n});\n\n/**\n * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n * @param {HTMLElement} doc SVG document to parse\n * @param {TSvgParsedCallback} callback Invoked when the parsing is done, with null if parsing wasn't possible with the list of svg nodes.\n * @param {TSvgReviverCallback} [reviver] Extra callback for further parsing of SVG elements, called after each fabric object has been created.\n * Takes as input the original svg element and the generated `FabricObject` as arguments. Used to inspect extra properties not parsed by fabric,\n * or extra custom manipulation\n * @param {Object} [options] Object containing options for parsing\n * @param {String} [options.crossOrigin] crossOrigin setting to use for external resources\n * @param {AbortSignal} [options.signal] handle aborting, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n * @return {SVGParsingOutput}\n * {@link SVGParsingOutput} also receives `allElements` array as the last argument. This is the full list of svg nodes available in the document.\n * You may want to use it if you are trying to regroup the objects as they were originally grouped in the SVG. ( This was the reason why it was added )\n */\nexport async function parseSVGDocument(\n  doc: Document,\n  reviver?: TSvgReviverCallback,\n  { crossOrigin, signal }: LoadImageOptions = {},\n): Promise<SVGParsingOutput> {\n  if (signal && signal.aborted) {\n    log('log', new SignalAbortedError('parseSVGDocument'));\n    // this is an unhappy path, we dont care about speed\n    return createEmptyResponse();\n  }\n  const documentElement = doc.documentElement;\n  parseUseDirectives(doc);\n\n  const descendants = Array.from(documentElement.getElementsByTagName('*')),\n    options = {\n      ...applyViewboxTransform(documentElement),\n      crossOrigin,\n      signal,\n    };\n  const elements = descendants.filter((el) => {\n    applyViewboxTransform(el);\n    return isValidSvgTag(el) && !hasInvalidAncestor(el); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n  });\n  if (!elements || (elements && !elements.length)) {\n    return {\n      ...createEmptyResponse(),\n      options,\n      allElements: descendants,\n    };\n  }\n  const localClipPaths: Record<string, Element[]> = {};\n  descendants\n    .filter((el) => getTagName(el) === 'clipPath')\n    .forEach((el) => {\n      el.setAttribute('originalTransform', el.getAttribute('transform') || '');\n      const id = el.getAttribute('id')!;\n      localClipPaths[id] = Array.from(el.getElementsByTagName('*')).filter(\n        (el) => isValidSvgTag(el),\n      );\n    });\n\n  // Precedence of rules:   style > class > attribute\n  const elementParser = new ElementsParser(\n    elements,\n    options,\n    reviver,\n    doc,\n    localClipPaths,\n  );\n\n  const instances = await elementParser.parse();\n\n  return {\n    objects: instances,\n    elements,\n    options,\n    allElements: descendants,\n  };\n}\n"],"names":["isValidSvgTag","el","svgValidTagNamesRegEx","test","getTagName","createEmptyResponse","objects","elements","options","allElements","async","parseSVGDocument","doc","reviver","crossOrigin","signal","arguments","length","undefined","aborted","log","SignalAbortedError","documentElement","parseUseDirectives","descendants","Array","from","getElementsByTagName","applyViewboxTransform","filter","hasInvalidAncestor","localClipPaths","forEach","setAttribute","getAttribute","id","elementParser","ElementsParser","parse"],"mappings":"qcAUA,MAAMA,EAAiBC,GACrBC,EAAsBC,KAAKC,EAAWH,IAE3BI,EAAsBA,KAAAA,CACjCC,QAAS,GACTC,SAAU,GACVC,QAAS,CAAA,EACTC,YAAa,KAiBRC,eAAeC,EACpBC,EACAC,GAE2B,IAD3BC,YAAEA,EAAWC,OAAEA,GAA0BC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAA,EAE5C,GAAID,GAAUA,EAAOI,QAGnB,OAFAC,EAAI,MAAO,IAAIC,EAAmB,qBA3BHhB,CACjCC,QAAS,GACTC,SAAU,GACVC,QAAS,CAAA,EACTC,YAAa,IA2Bb,MAAMa,EAAkBV,EAAIU,gBAC5BC,EAAmBX,GAEnB,MAAMY,EAAcC,MAAMC,KAAKJ,EAAgBK,qBAAqB,MAClEnB,EAAU,IACLoB,EAAsBN,GACzBR,cACAC,UAEER,EAAWiB,EAAYK,OAAQ5B,IACnC2B,EAAsB3B,GACfD,EAAcC,KAAQ6B,EAAmB7B,KAElD,IAAKM,GAAaA,IAAaA,EAASU,OACtC,MAAO,CA5CTX,QAAS,GACTC,SAAU,GACVC,QAAS,CAAA,EACTC,YAAa,GA2CTD,UACAC,YAAae,GAGjB,MAAMO,EAA4C,CAAA,EAClDP,EACGK,OAAQ5B,GAA0B,aAAnBG,EAAWH,IAC1B+B,QAAS/B,IACRA,EAAGgC,aAAa,oBAAqBhC,EAAGiC,aAAa,cAAgB,IACrE,MAAMC,EAAKlC,EAAGiC,aAAa,MAC3BH,EAAeI,GAAMV,MAAMC,KAAKzB,EAAG0B,qBAAqB,MAAME,OAC3D5B,GAAOD,EAAcC,MAK5B,MAAMmC,EAAgB,IAAIC,EACxB9B,EACAC,EACAK,EACAD,EACAmB,GAKF,MAAO,CACLzB,cAHsB8B,EAAcE,QAIpC/B,WACAC,UACAC,YAAae,EAEjB"}