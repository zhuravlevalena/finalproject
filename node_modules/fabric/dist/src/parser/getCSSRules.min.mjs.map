{"version":3,"file":"getCSSRules.min.mjs","sources":["../../../src/parser/getCSSRules.ts"],"sourcesContent":["import type { CSSRules } from './typedefs';\n\n/**\n * Returns CSS rules for a given SVG document\n * @param {HTMLElement} doc SVG document to parse\n * @return {Object} CSS rules of this document\n */\nexport function getCSSRules(doc: Document) {\n  const styles = doc.getElementsByTagName('style');\n  const allRules: CSSRules = {};\n\n  // very crude parsing of style contents\n  for (let i = 0; i < styles.length; i++) {\n    const styleContents = (styles[i].textContent || '').replace(\n      // remove comments\n      /\\/\\*[\\s\\S]*?\\*\\//g,\n      '',\n    );\n\n    if (styleContents.trim() === '') {\n      continue;\n    }\n    // recovers all the rule in this form `body { style code... }`\n    // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n    styleContents\n      .split('}')\n      // remove empty rules and remove everything if we didn't split in at least 2 pieces\n      .filter((rule, index, array) => array.length > 1 && rule.trim())\n      // at this point we have hopefully an array of rules `body { style code... `\n      .forEach((rule) => {\n        // if there is more than one opening bracket and the rule starts with '@', it is likely\n        // a nested at-rule like @media, @supports, @scope, etc. Ignore these as the code below\n        // can not handle it.\n        if (\n          (rule.match(/{/g) || []).length > 1 &&\n          rule.trim().startsWith('@')\n        ) {\n          return;\n        }\n\n        const match = rule.split('{'),\n          ruleObj: Record<string, string> = {},\n          declaration = match[1].trim(),\n          propertyValuePairs = declaration.split(';').filter(function (pair) {\n            return pair.trim();\n          });\n\n        for (let j = 0; j < propertyValuePairs.length; j++) {\n          const pair = propertyValuePairs[j].split(':'),\n            property = pair[0].trim(),\n            value = pair[1].trim();\n          ruleObj[property] = value;\n        }\n        rule = match[0].trim();\n        rule.split(',').forEach((_rule) => {\n          _rule = _rule.replace(/^svg/i, '').trim();\n          if (_rule === '') {\n            return;\n          }\n          allRules[_rule] = {\n            ...(allRules[_rule] || {}),\n            ...ruleObj,\n          };\n        });\n      });\n  }\n  return allRules;\n}\n"],"names":["getCSSRules","doc","styles","getElementsByTagName","allRules","i","length","styleContents","textContent","replace","trim","split","filter","rule","index","array","forEach","match","startsWith","ruleObj","propertyValuePairs","pair","j","property","value","_rule"],"mappings":"AAOO,SAASA,EAAYC,GAC1B,MAAMC,EAASD,EAAIE,qBAAqB,SAClCC,EAAqB,CAAA,EAG3B,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAOI,OAAQD,IAAK,CACtC,MAAME,GAAiBL,EAAOG,GAAGG,aAAe,IAAIC,QAElD,oBACA,IAG2B,KAAzBF,EAAcG,QAKlBH,EACGI,MAAM,KAENC,OAAO,CAACC,EAAMC,EAAOC,IAAUA,EAAMT,OAAS,GAAKO,EAAKH,QAExDM,QAASH,IAIR,IACGA,EAAKI,MAAM,OAAS,IAAIX,OAAS,GAClCO,EAAKH,OAAOQ,WAAW,KAEvB,OAGF,MAAMD,EAAQJ,EAAKF,MAAM,KACvBQ,EAAkC,CAAA,EAElCC,EADcH,EAAM,GAAGP,OACUC,MAAM,KAAKC,OAAO,SAAUS,GAC3D,OAAOA,EAAKX,MACd,GAEF,IAAK,IAAIY,EAAI,EAAGA,EAAIF,EAAmBd,OAAQgB,IAAK,CAClD,MAAMD,EAAOD,EAAmBE,GAAGX,MAAM,KACvCY,EAAWF,EAAK,GAAGX,OACnBc,EAAQH,EAAK,GAAGX,OAClBS,EAAQI,GAAYC,CACtB,EACAX,EAAOI,EAAM,GAAGP,QACXC,MAAM,KAAKK,QAASS,IAET,MADdA,EAAQA,EAAMhB,QAAQ,QAAS,IAAIC,UAInCN,EAASqB,GAAS,IACZrB,EAASqB,IAAU,MACpBN,OAIb,CACA,OAAOf,CACT"}