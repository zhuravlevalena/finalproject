import{Gradient as t}from"../gradient/Gradient.min.mjs";import{Group as e}from"../shapes/Group.min.mjs";import{FabricImage as i}from"../shapes/Image.min.mjs";import{classRegistry as s}from"../ClassRegistry.min.mjs";import{invertTransform as r,multiplyTransformMatrices as n,qrDecompose as a}from"../util/misc/matrix.min.mjs";import{removeTransformMatrixForSvgParsing as o}from"../util/transform_matrix_removal.min.mjs";import{Point as m}from"../Point.min.mjs";import{FILL as l,STROKE as p,CENTER as c}from"../constants.min.mjs";import{getGradientDefs as h}from"./getGradientDefs.min.mjs";import{getCSSRules as f}from"./getCSSRules.min.mjs";import{getTagName as u}from"./getTagName.min.mjs";import{parseTransformAttribute as g}from"./parseTransformAttribute.min.mjs";const P=t=>s.getSVGClass(u(t).toLowerCase());class d{constructor(t,e,i,s,r){this.elements=t,this.options=e,this.reviver=i,this.regexUrl=/^url\(['"]?#([^'"]+)['"]?\)/g,this.doc=s,this.clipPaths=r,this.gradientDefs=h(s),this.cssRules=f(s)}parse(){return Promise.all(this.elements.map(t=>this.createObject(t)))}async createObject(t){const e=P(t);if(e){const s=await e.fromElement(t,this.options,this.cssRules);return this.resolveGradient(s,t,l),this.resolveGradient(s,t,p),s instanceof i&&s._originalElement?o(s,s.parsePreserveAspectRatioAttribute()):o(s),await this.resolveClipPath(s,t),this.reviver&&this.reviver(t,s),s}return null}extractPropertyDefinition(t,e,i){const s=t[e],r=this.regexUrl;if(!r.test(s))return;r.lastIndex=0;const n=r.exec(s)[1];return r.lastIndex=0,i[n]}resolveGradient(e,i,s){const r=this.extractPropertyDefinition(e,s,this.gradientDefs);if(r){const n=i.getAttribute(s+"-opacity"),a=t.fromElement(r,e,{...this.options,opacity:n});e.set(s,a)}}async resolveClipPath(t,i,s){const l=this.extractPropertyDefinition(t,"clipPath",this.clipPaths);if(l){const p=r(t.calcTransformMatrix()),h=l[0].parentElement;let f=i;for(;!s&&f.parentElement&&f.getAttribute("clip-path")!==t.clipPath;)f=f.parentElement;f.parentElement.appendChild(h);const u=g(`${f.getAttribute("transform")||""} ${h.getAttribute("originalTransform")||""}`);h.setAttribute("transform",`matrix(${u.join(",")})`);const d=await Promise.all(l.map(t=>P(t).fromElement(t,this.options,this.cssRules).then(t=>(o(t),t.fillRule=t.clipRule,delete t.clipRule,t)))),j=1===d.length?d[0]:new e(d),v=n(p,j.calcTransformMatrix());j.clipPath&&await this.resolveClipPath(j,f,h.getAttribute("clip-path")?f:void 0);const{scaleX:x,scaleY:b,angle:w,skewX:y,translateX:A,translateY:R}=a(v);j.set({flipX:!1,flipY:!1}),j.set({scaleX:x,scaleY:b,angle:w,skewX:y,skewY:0}),j.setPositionByOrigin(new m(A,R),c,c),t.clipPath=j}else delete t.clipPath}}export{d as ElementsParser};
//# sourceMappingURL=elements_parser.min.mjs.map
