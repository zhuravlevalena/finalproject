import{iMatrix as t,ROTATE as r,SKEW_Y as e,SKEW_X as a,SCALE as n}from"../constants.min.mjs";import{reNum as s}from"./constants.min.mjs";import{cleanupSvgAttribute as i}from"../util/internals/cleanupSvgAttribute.min.mjs";import{createRotateMatrix as $,multiplyTransformMatrixArray as c,createSkewYMatrix as m,createSkewXMatrix as o,createScaleMatrix as g,createTranslateMatrix as l}from"../util/misc/matrix.min.mjs";const p=`(${s})`,w=String.raw`(skewX)\(${p}\)`,f=String.raw`(skewY)\(${p}\)`,u=String.raw`(rotate)\(${p}(?: ${p} ${p})?\)`,x=String.raw`(scale)\(${p}(?: ${p})?\)`,S=String.raw`(translate)\(${p}(?: ${p})?\)`,k=`(?:${String.raw`(matrix)\(${p} ${p} ${p} ${p} ${p} ${p}\)`}|${S}|${u}|${x}|${w}|${f})`,b=`(?:${k}*)`,j=String.raw`^\s*(?:${b}?)\s*$`,h=new RegExp(j),E=new RegExp(k),R=new RegExp(k,"g");function A(s){const p=[];if(!(s=i(s).replace(/\s*([()])\s*/gi,"$1"))||s&&!h.test(s))return[...t];for(const i of s.matchAll(R)){const s=E.exec(i[0]);if(!s)continue;let c=t;const w=s.filter(t=>!!t),[,f,...u]=w,[x,S,k,b,j,h]=u.map(t=>parseFloat(t));switch(f){case"translate":c=l(x,S);break;case r:c=$({angle:x},{x:S,y:k});break;case n:c=g(x,S);break;case a:c=o(x);break;case e:c=m(x);break;case"matrix":c=[x,S,k,b,j,h]}p.push(c)}return c(p)}export{A as parseTransformAttribute};
//# sourceMappingURL=parseTransformAttribute.min.mjs.map
